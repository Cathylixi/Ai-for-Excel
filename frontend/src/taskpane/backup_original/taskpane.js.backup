/*
 * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
 * See LICENSE in the project root for license information.
 */

/* global console, document, Excel, Office */

// åç«¯APIåŸºç¡€URL - ä½¿ç”¨HTTPSé¿å…æ··åˆå†…å®¹é—®é¢˜
const API_BASE_URL = 'https://localhost:4000';

// å…¨å±€å˜é‡
let uploadedProtocol = null;

// ExcelçŠ¶æ€ç¼“å­˜ç³»ç»Ÿ - ç”¨äºBackå¯¼èˆªæ—¶æ¢å¤Excelå†…å®¹
let excelStateCache = {
  step1: null,   // AI Assistant (ç©ºç™½çŠ¶æ€)
  step2: null,   // Uploadå®Œæˆåï¼ˆé€šå¸¸å¯¹Excelæ— æ”¹åŠ¨ï¼‰
  step3: null,   // Project Selectionå®Œæˆå + Excel Headers
  step4: null,   // Analysis Progressï¼ˆå ä½ï¼‰
  step5: null,   // SDTM Analysisç»“æœé¡µ
  step6: null    // å®Œæˆç¡®è®¤é¡µï¼ˆå ä½ï¼‰
};

// ğŸ”„ Excelå˜åŒ–ç›‘å¬å’Œæ•°æ®åŒæ­¥
let isTrackingChanges = false;
let changeTimeout = null;

async function initExcelChangeTracking() {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // ç›‘å¬å•å…ƒæ ¼å˜åŒ–äº‹ä»¶ï¼ˆä½¿ç”¨äº‹ä»¶å‚æ•°çš„ address/worksheetId è·å– Rangeï¼‰
      worksheet.onChanged.add(async (args) => {
        try {
          await Excel.run(async (innerContext) => {
            const sheet = innerContext.workbook.worksheets.getItem(args.worksheetId);
            const changedRange = sheet.getRange(args.address);
            changedRange.load([ 'columnIndex', 'columnCount' ]);
            await innerContext.sync();
            
            // æ˜¯å¦åŒ…å«Båˆ—ï¼Ÿ
            const startCol = changedRange.columnIndex; // 0-based
            const endCol = startCol + changedRange.columnCount - 1;
            const includesB = (startCol <= 1 && endCol >= 1);
            if (!includesB) return;
            
            // é˜²æŠ–ä¿å­˜
            if (changeTimeout) { clearTimeout(changeTimeout); }
            changeTimeout = setTimeout(async () => {
              await saveExcelChangesToDatabase();
            }, 1000);
          });
        } catch (err) {
          console.error('âŒ Excel onChanged å¤„ç†å¤±è´¥:', err);
        }
      });
      
      await context.sync();
      console.log('âœ… Excelå˜åŒ–ç›‘å¬å·²å¯ç”¨');
    });
  } catch (error) {
    console.error('âŒ åˆå§‹åŒ–Excelå˜åŒ–ç›‘å¬å¤±è´¥:', error);
  }
}


async function saveExcelChangesToDatabase() {
  if (!window.currentDocumentId) {
    console.warn('âš ï¸ æ²¡æœ‰æœ‰æ•ˆçš„æ–‡æ¡£IDï¼Œè·³è¿‡ä¿å­˜');
    return;
  }
  
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      const usedRange = worksheet.getUsedRange();
      usedRange.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();
      
      const rows = usedRange.values;
      const updatedUnits = {};
      
      // æå–æ‰€æœ‰Unitå€¼ï¼ˆBåˆ—ï¼‰
      for (let r = 0; r < rows.length; r++) {
        const taskName = String(rows[r][0] || '').trim();
        const unitValue = rows[r][1]; // Båˆ—
        
        if (taskName && unitValue !== undefined && unitValue !== '') {
          // æ˜ å°„ä»»åŠ¡åç§°åˆ°key
          const taskKey = getTaskKeyFromName(taskName);
          if (taskKey) {
            updatedUnits[taskKey] = Number(unitValue) || 0;
          }
        }
      }
      
      // å‘é€åˆ°åç«¯ä¿å­˜ï¼ˆå¯å¹¶å‘æ›´æ–°ï¼‰
      const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/update-units`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ units: updatedUnits })
      });
      
      const result = await response.json();
      if (result.success) {
        console.log('âœ… Excel Unitå˜åŒ–å·²åŒæ­¥åˆ°æ•°æ®åº“');
        showStatusMessage('Units updated and saved automatically!', 'success');
      } else {
        console.warn('âš ï¸ ä¿å­˜Unitå˜åŒ–å¤±è´¥:', result.message);
      }
    });
  } catch (error) {
    console.error('âŒ ä¿å­˜Excelå˜åŒ–åˆ°æ•°æ®åº“å¤±è´¥:', error);
    showStatusMessage('Failed to save changes: ' + error.message, 'error');
  }
}

// è¾…åŠ©å‡½æ•°ï¼šä»ä»»åŠ¡åç§°è·å–å¯¹åº”çš„key
function getTaskKeyFromName(taskName) {
  const taskMapping = {
    // SDTM family (match the exact row titles we render in Excel)
    'SDTM Annotated CRFs (aCRF)': 'annotatedCrf',
    'SDTM Dataset Specs (High Complexity)': 'specsHigh',
    'SDTM Dataset Specs (Medium Complexity)': 'specsMedium',
    'SDTM Production and Validation: Programs and Datasets (High Complexity)': 'prodHigh',
    'SDTM Production and Validation: Programs and Datasets (Medium Complexity)': 'prodMedium',
    'SDTM Pinnacle 21 Report Creation and Review': 'pinnacle21',
    "SDTM Reviewer's Guide": 'reviewersGuide',
    'SDTM Define.xml': 'defineXml',
    'SDTM Dataset File xpt Conversion and Review': 'xptConversion',

    // ADaM family
    'ADaM Dataset Specs (High Complexity)': 'adam_specs_high',
    'ADaM Dataset Specs (Medium Complexity)': 'adam_specs_medium',
    'ADaM Production and Validation: Programs and Datasets (High Complexity)': 'adam_prod_high',
    'ADaM Production and Validation: Programs and Datasets (Medium Complexity)': 'adam_prod_medium',
    'ADaM Pinnacle 21 Report Creation and Review': 'adam_pinnacle21',
    'ADaM Review\'s Guide': 'adam_reviewersGuide',
    'ADaM Define.xml': 'adam_defineXml',
    'ADaM Dataset Program xpt Conversion and Review': 'adam_xptConversion',
    'ADaM Program txt Conversion and Review': 'adam_txtConversion',

    // Other analysis tasks
    'Statistical Analysis Plan Draft 1': 'sap_draft1',
    'Statistical Analysis Plan Draft 2': 'sap_draft2',
    'Statistical Analysis Plan Final': 'sap_final',
    'Analysis Shells Development': 'analysis_shells',
    'Mock Tables, Listings, and Figures': 'mock_tlfs',

    // Generic fallbacks (legacy)
    'Statistical Analysis Plan (SAP)': 'sap',
    'Tables, Listings, and Figures (TLFs)': 'tlfs',
    'Interim Analysis': 'interim_analysis',
    'Final Analysis': 'final_analysis',
    'CDISC Data Transfer to Sponsor': 'data_transfer'
  };
  
  return taskMapping[taskName] || null;
}

// ğŸ”„ ExcelçŠ¶æ€ç®¡ç†å‡½æ•°
async function cacheExcelState(stepNumber) {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      const usedRange = worksheet.getUsedRange();
      
      if (usedRange) {
        usedRange.load(['values', 'formulas', 'format/fill/color', 'format/font', 'format/borders', 'format/numberFormat']);
        await context.sync();
        
        // ç¼“å­˜Excelå†…å®¹å’Œæ ¼å¼
        excelStateCache[`step${stepNumber}`] = {
          values: usedRange.values,
          formulas: usedRange.formulas,
          rowCount: usedRange.rowCount,
          columnCount: usedRange.columnCount,
          cached: true,
          timestamp: new Date().toISOString()
        };
        
        console.log(`âœ… ExcelçŠ¶æ€å·²ç¼“å­˜åˆ° step${stepNumber}:`, excelStateCache[`step${stepNumber}`]);
      } else {
        // ç©ºç™½çŠ¶æ€
        excelStateCache[`step${stepNumber}`] = {
          isEmpty: true,
          cached: true,
          timestamp: new Date().toISOString()
        };
        console.log(`âœ… ç©ºç™½ExcelçŠ¶æ€å·²ç¼“å­˜åˆ° step${stepNumber}`);
      }
    });
  } catch (error) {
    console.error(`âŒ ç¼“å­˜ExcelçŠ¶æ€å¤±è´¥ (step${stepNumber}):`, error);
  }
}

async function restoreExcelState(stepNumber) {
  try {
    const cachedState = excelStateCache[`step${stepNumber}`];
    if (!cachedState || !cachedState.cached) {
      console.log(`âš ï¸ æ²¡æœ‰æ‰¾åˆ° step${stepNumber} çš„ç¼“å­˜çŠ¶æ€`);
      return;
    }
    
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // å…ˆæ¸…ç©ºå½“å‰å†…å®¹
      const usedRange = worksheet.getUsedRange();
      if (usedRange) {
        usedRange.clear();
        await context.sync();
      }
      
      if (cachedState.isEmpty) {
        // æ¢å¤ç©ºç™½çŠ¶æ€
        console.log(`âœ… å·²æ¢å¤ç©ºç™½ExcelçŠ¶æ€ (step${stepNumber})`);
        return;
      }
      
      // æ¢å¤ç¼“å­˜çš„å†…å®¹
      if (cachedState.values && cachedState.values.length > 0) {
        const range = worksheet.getRangeByIndexes(0, 0, cachedState.rowCount, cachedState.columnCount);
        
        // æ¢å¤æ•°å€¼å’Œå…¬å¼
        if (cachedState.formulas) {
          range.formulas = cachedState.formulas;
        } else {
          range.values = cachedState.values;
        }
        
        await context.sync();
        console.log(`âœ… å·²æ¢å¤ExcelçŠ¶æ€åˆ° step${stepNumber}`);
      }
    });
    
    showStatusMessage(`Excel content restored to Step ${stepNumber} state.`, 'success');
  } catch (error) {
    console.error(`âŒ æ¢å¤ExcelçŠ¶æ€å¤±è´¥ (step${stepNumber}):`, error);
    showStatusMessage(`Failed to restore Excel state: ${error.message}`, 'error');
  }
}

// Wizard state
let currentWizardStep = 1; // 1: Welcome, 2: Resume, 3: Project, 4: Upload, 5: SDTM

function initWizard() {
  const backBtn = document.getElementById('wizard-back-btn');
  const nextBtn = document.getElementById('wizard-next-btn');
  backBtn.addEventListener('click', async () => {
    // æ™ºèƒ½Backå¯¼èˆªï¼šè·³è¿‡è¢«åˆ é™¤çš„Step 2ï¼ŒåŒæ—¶æ¢å¤ExcelçŠ¶æ€
    let targetStep = null;
    
    if (currentWizardStep === 2) {
      targetStep = 1;  // Upload â†’ AI
    } else if (currentWizardStep === 3) {
      targetStep = 2;  // Project Selection â†’ Upload
    } else if (currentWizardStep === 4) {
      targetStep = 3;  // Analysis Progress â†’ Project Selectionï¼ˆè¿›åº¦é¡µè¿”å›ä¸Šä¸€æ­¥ï¼‰
    } else if (currentWizardStep === 5) {
      targetStep = 4;  // Results â†’ Analysis Progressï¼ˆä¿æŒä¸€è‡´æ€§ï¼‰
    } else if (currentWizardStep === 6) {
      targetStep = 5;  // Completion â†’ Results
    } else if (currentWizardStep > 1) {
      targetStep = currentWizardStep - 1;
    }
    
    if (targetStep) {
      // å…ˆæ¢å¤ExcelçŠ¶æ€ï¼Œå†åˆ‡æ¢é¡µé¢
      await restoreExcelState(targetStep);
      showStep(targetStep);
    }
  });
  nextBtn.addEventListener('click', async () => { await handleNext(); });
  
  // åˆå§‹åŒ–èŠå¤©ç•Œé¢
  initChatInterface();
  
  showStep(1);
}

// åˆå§‹åŒ–èŠå¤©ç•Œé¢
function initChatInterface() {
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  
  if (chatInput && chatSendBtn) {
    // å‘é€æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    chatSendBtn.addEventListener('click', handleChatSend);
    
    // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleChatSend();
      }
    });
    
    // è¾“å…¥æ¡†ç„¦ç‚¹äº‹ä»¶
    chatInput.addEventListener('input', () => {
      const sendBtn = document.getElementById('chat-send-btn');
      const hasText = chatInput.value.trim().length > 0;
      sendBtn.disabled = !hasText;
    });
  }
}

// ğŸ”¥ é‡ç½®AIèŠå¤©ç•Œé¢åˆ°åˆå§‹çŠ¶æ€
function resetAIChatInterface() {
  const chatMessages = document.getElementById('chat-messages');
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  
  if (chatMessages) {
    // æ¸…ç©ºæ‰€æœ‰èŠå¤©æ¶ˆæ¯
    chatMessages.innerHTML = '';
    
    // é‡æ–°æ·»åŠ åˆå§‹æ¬¢è¿æ¶ˆæ¯
    const initialMessage = document.createElement('div');
    initialMessage.className = 'message ai-message';
    initialMessage.innerHTML = `
      <div class="message-content">
        Hello! What would you like to do today? 
        <br><br>You can say something like:
        <br>â€¢ "I want to do Phase II study cost analysis for study SK123-kbi"
        <br>â€¢ "Help me estimate costs for an oncology trial (study number: ABC-123)"
        <br>â€¢ "I need SDTM mapping for study SK123-kbi protocol"
      </div>
    `;
    chatMessages.appendChild(initialMessage);
  }
  
  // æ¸…ç©ºè¾“å…¥æ¡†
  if (chatInput) {
    chatInput.value = '';
  }
  
  // é‡ç½®å‘é€æŒ‰é’®çŠ¶æ€
  if (chatSendBtn) {
    chatSendBtn.disabled = true;
  }
  
  // é‡ç½®ç›¸å…³çŠ¶æ€å˜é‡
  lastParsedCommand = null;
  
  console.log('âœ… AIèŠå¤©ç•Œé¢å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€');
}

// æœ€è¿‘ä¸€æ¬¡è§£æç»“æœ
let lastParsedCommand = null;

// å¤„ç†èŠå¤©å‘é€ï¼ˆè°ƒç”¨åç«¯è§£æ â†’ ç¡®è®¤ â†’ æŸ¥åº“ â†’ å¯¼èˆªï¼‰
async function handleChatSend() {
  const chatInput = document.getElementById('chat-input');
  const userMessage = chatInput.value.trim();
  if (!userMessage) return;

  addChatMessage(userMessage, 'user');
  chatInput.value = '';
  document.getElementById('chat-send-btn').disabled = true;

  // æ£€æŸ¥æ˜¯å¦åœ¨ç­‰å¾…ç¡®è®¤çŠ¶æ€
  if (window.pendingConfirmation) {
    await handleConfirmationResponse(userMessage);
    return;
  }

  showTypingIndicator();
  try {
    const parsed = await callAssistantParseCommand(userMessage);
    hideTypingIndicator();

    if (!parsed || (!parsed.studyIdentifier && !parsed.matchedTask)) {
      // æ£€æŸ¥æ˜¯å¦æ˜¯é€šç”¨çš„"å¼€å§‹æ–°é¡¹ç›®"è¯·æ±‚
      if (userMessage.toLowerCase().includes('start') || userMessage.toLowerCase().includes('new project') || userMessage.toLowerCase().includes('upload')) {
        addChatMessage("Let me take you to start a new project by uploading your protocol.", 'ai');
        await delayedNavigation(3);
        return;
      }
      addChatMessage("I couldn't understand the study number or task. Supported tasks are: Cost Estimate, SAS Analysis. Please try e.g. 'I want to do Cost Estimate for study SK123-KBI', or say 'start new project'.", 'ai');
      return;
    }

    lastParsedCommand = parsed;
    const studyText = parsed.studyIdentifier ? parsed.studyIdentifier : '(study number not provided)';
    const taskText = parsed.matchedTask ? parsed.matchedTask.name : '(task not recognized)';
    askForConfirmation(studyText, taskText, parsed.matchedTask ? parsed.matchedTask.key : null);
      } catch (e) {
      hideTypingIndicator();
      addChatMessage('Sorry, parsing failed. Please try again, or say "start new project" to proceed with upload.', 'ai');
    }
}

async function callAssistantParseCommand(text) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/parse-command`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text })
  });
  if (!resp.ok) throw new Error('parse failed');
  const data = await resp.json();
  return data?.data || null;
}

function askForConfirmation(studyIdentifier, taskName, taskKey) {
  const msg = `Did you mean you want ${taskName} for study ${studyIdentifier}?`;
  addChatMessage(msg, 'ai');
  
  // è®¾ç½®ç­‰å¾…ç¡®è®¤çŠ¶æ€
  window.pendingConfirmation = {
    studyIdentifier,
    taskName,
    taskKey
  };
}

async function handleConfirmationResponse(userMessage) {
  showTypingIndicator();
  
  try {
    // è°ƒç”¨AIè§£æç”¨æˆ·çš„Yes/Noæ„å‘
    const intent = await parseYesNoIntent(userMessage);
    hideTypingIndicator();
    
    if (intent === 'yes') {
      const { studyIdentifier, taskKey } = window.pendingConfirmation;
      if (!taskKey) {
        addChatMessage('Task not recognized. Supported tasks: Cost Estimate, SAS Analysis. Please rephrase your request.', 'ai');
        window.pendingConfirmation = null;
        return;
      }
      
      showTypingIndicator();
      try {
        const lookup = await callAssistantLookupStudyTask(studyIdentifier, taskKey);
        hideTypingIndicator();
        window.pendingConfirmation = null;
        await handleLookupResult(lookup);
      } catch (err) {
        hideTypingIndicator();
        addChatMessage('Lookup failed. Let me take you to start a new project.', 'ai');
        window.pendingConfirmation = null;
        await delayedNavigation(3);
      }
    } else if (intent === 'no') {
      window.pendingConfirmation = null;
      addChatMessage("Please tell me again what you want to do. For example: 'I want to do Cost Estimate for study SK123-KBI'.", 'ai');
    } else {
      addChatMessage("I couldn't understand if you meant yes or no. Please respond with something like 'yes', 'no', 'correct', or 'not correct'.", 'ai');
    }
  } catch (e) {
    hideTypingIndicator();
    addChatMessage("Sorry, I couldn't process your response. Please say 'yes' or 'no'.", 'ai');
  } finally {
    document.getElementById('chat-send-btn').disabled = false;
  }
}

async function parseYesNoIntent(text) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/parse-command`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      text: `Parse this as yes/no intent: "${text}". Return only "yes", "no", or "unclear".`,
      type: 'yesno_intent'
    })
  });
  
  if (!resp.ok) throw new Error('Intent parsing failed');
  const data = await resp.json();
  
  // ç®€å•çš„å®¢æˆ·ç«¯è§£æä½œä¸ºå¤‡é€‰
  const lowerText = text.toLowerCase().trim();
  
  // å„ç§Yesçš„è¡¨è¾¾æ–¹å¼
  const yesPatterns = [
    'yes', 'y', 'yeah', 'yep', 'correct', 'right', 'true', 'ok', 'okay', 
    'sure', 'exactly', 'that\'s right', 'confirm', 'confirmed', 'agreed'
  ];
  
  // å„ç§Noçš„è¡¨è¾¾æ–¹å¼  
  const noPatterns = [
    'no', 'n', 'nope', 'wrong', 'incorrect', 'false', 'not right', 
    'not correct', 'that\'s wrong', 'cancel', 'redo'
  ];
  
  if (yesPatterns.some(pattern => lowerText.includes(pattern))) {
    return 'yes';
  } else if (noPatterns.some(pattern => lowerText.includes(pattern))) {
    return 'no';
  }
  
  return 'unclear';
}

async function callAssistantLookupStudyTask(studyIdentifier, taskKey) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/lookup-study-task`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ studyIdentifier, taskKey })
  });
  if (!resp.ok) throw new Error('lookup failed');
  const data = await resp.json();
  return data?.data || null;
}

async function handleLookupResult(data) {
  if (!data || data.foundStudy === false) {
    addChatMessage("We could not find any records for this study. Let me take you to start a new one.", 'ai');
    await delayedNavigation(2); // è·³è½¬åˆ°Uploadé¡µé¢ (Step 2)ï¼Œè€Œä¸æ˜¯Project Selection (Step 3)
    return;
  }

  // foundStudy === true
  if (data.isUnfinished === true && data.documentId) {
    addChatMessage(`I found an unfinished '${data.taskName}' for study '${data.studyNumber}'. Loading it now...`, 'ai');
    window.currentDocumentId = data.documentId;
    await saveDocumentIdToSettings(data.documentId);
    await delayedNavigationWithCallback(5, async () => {
      await restoreApplicationState(data.documentId);
    });
    return;
  }

  if (data.isUnfinished === false) {
    // é¡¹ç›®å·²å®Œæˆçš„æƒ…å†µ
    addChatMessage(`I found that '${data.taskName}' for study '${data.studyNumber}' is already completed. Let me take you to start a new one.`, 'ai');
  } else {
    // çŠ¶æ€ä¸æ˜ç¡®çš„æƒ…å†µ
    addChatMessage("We could not check unfinished project for this study. Let me take you to start a new one.", 'ai');
  }
  await delayedNavigation(2); // è·³è½¬åˆ°Uploadé¡µé¢ï¼Œè€Œä¸æ˜¯Project Selection
}

// å»¶è¿Ÿè·³è½¬åŠŸèƒ½ï¼ˆå¸¦è§†è§‰æç¤ºï¼‰
async function delayedNavigation(targetStep, delayMs = 2000) {
  // ç­‰å¾…AIæ¶ˆæ¯æ˜¾ç¤ºå®Œæ•´
  await new Promise(resolve => setTimeout(resolve, delayMs));
  
  // æ˜¾ç¤ºå‡†å¤‡è·³è½¬çš„æç¤º
  const countdownDiv = document.createElement('div');
  countdownDiv.className = 'message ai-message';
  countdownDiv.innerHTML = `<div class="message-content" style="font-style: italic; color: #666; border: 1px solid #e0e0e0; background-color: #f8f9fa; padding: 8px; border-radius: 6px;">Preparing to redirect...</div>`;
  
  const chatMessages = document.getElementById('chat-messages');
  chatMessages.appendChild(countdownDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // ç­‰å¾…1ç§’åè·³è½¬
  await new Promise(resolve => setTimeout(resolve, 1000));
  countdownDiv.remove();
  showStep(targetStep);
}

// å»¶è¿Ÿè·³è½¬åŠŸèƒ½ï¼ˆå¸¦å›è°ƒå‡½æ•°ï¼‰
async function delayedNavigationWithCallback(targetStep, callback, delayMs = 2000) {
  // ç­‰å¾…AIæ¶ˆæ¯æ˜¾ç¤ºå®Œæ•´
  await new Promise(resolve => setTimeout(resolve, delayMs));
  
  // æ˜¾ç¤ºå‡†å¤‡åŠ è½½çš„æç¤º
  const countdownDiv = document.createElement('div');
  countdownDiv.className = 'message ai-message';
  countdownDiv.innerHTML = `<div class="message-content" style="font-style: italic; color: #666; border: 1px solid #e0e0e0; background-color: #f8f9fa; padding: 8px; border-radius: 6px;">Loading previous work...</div>`;
  
  const chatMessages = document.getElementById('chat-messages');
  chatMessages.appendChild(countdownDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // ç­‰å¾…1ç§’åæ‰§è¡Œå›è°ƒå’Œè·³è½¬
  await new Promise(resolve => setTimeout(resolve, 1000));
  countdownDiv.remove();
  
  if (callback) await callback();
  showStep(targetStep);
}

// æ·»åŠ èŠå¤©æ¶ˆæ¯
function addChatMessage(message, sender) {
  const chatMessages = document.getElementById('chat-messages');
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${sender}-message`;
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'message-content';
  
  contentDiv.textContent = message;
  
  messageDiv.appendChild(contentDiv);
  chatMessages.appendChild(messageDiv);
  
  // æ»šåŠ¨åˆ°åº•éƒ¨
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// æ˜¾ç¤ºæ‰“å­—æŒ‡ç¤ºå™¨
function showTypingIndicator() {
  const chatMessages = document.getElementById('chat-messages');
  const typingDiv = document.createElement('div');
  typingDiv.className = 'message ai-message typing-indicator';
  typingDiv.id = 'typing-indicator';
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'message-content';
  contentDiv.innerHTML = '<strong>LLX AI:</strong> <span class="typing-dots">Thinking<span>.</span><span>.</span><span>.</span></span>';
  
  typingDiv.appendChild(contentDiv);
  chatMessages.appendChild(typingDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// éšè—æ‰“å­—æŒ‡ç¤ºå™¨
function hideTypingIndicator() {
  const typingIndicator = document.getElementById('typing-indicator');
  if (typingIndicator) {
    typingIndicator.remove();
  }
}

// ç”ŸæˆAIå›å¤
function generateAIResponse(userMessage) {
  const lowerMessage = userMessage.toLowerCase();
  
  // åŒ¹é…ç ”ç©¶ç±»å‹å…³é”®è¯
  if (lowerMessage.includes('phase') || lowerMessage.includes('study') || lowerMessage.includes('trial')) {
    if (lowerMessage.includes('phase i') || lowerMessage.includes('phase 1')) {
      return "Great! I understand you're working on a Phase I study. Phase I trials typically focus on safety and dosing. I'll help you set up a cost analysis that includes SDTM mapping, safety monitoring, and PK assessments. Click 'Next' to begin the protocol upload.";
    } else if (lowerMessage.includes('phase ii') || lowerMessage.includes('phase 2')) {
      return "Excellent! Phase II studies focus on efficacy while continuing safety monitoring. I'll guide you through setting up cost estimates for SDTM datasets, efficacy endpoints, and interim analyses. Click 'Next' to start with your protocol.";
    } else if (lowerMessage.includes('phase iii') || lowerMessage.includes('phase 3')) {
      return "Perfect! Phase III trials are large confirmatory studies. I'll help you plan for extensive SDTM/ADaM datasets, multiple interim analyses, and comprehensive safety reporting. Let's begin with uploading your protocol - click 'Next'.";
    }
  }
  
  // åŒ¹é…æ²»ç–—é¢†åŸŸ
  if (lowerMessage.includes('oncology') || lowerMessage.includes('cancer')) {
    return "Oncology trials have specific requirements including tumor assessments, survival endpoints, and specialized SDTM domains like TU (Tumor Identification) and RS (Disease Response). I'll help you set up the appropriate cost structure. Click 'Next' to upload your protocol.";
  }
  
  // åŒ¹é…SDTMç›¸å…³
  if (lowerMessage.includes('sdtm') || lowerMessage.includes('mapping')) {
    return "SDTM mapping is crucial for regulatory submissions! I'll analyze your protocol's Schedule of Assessments and automatically map procedures to appropriate SDTM domains, then estimate the complexity and costs. Ready to start? Click 'Next' to upload your protocol.";
  }
  
  // åŒ¹é…æˆæœ¬åˆ†æ
  if (lowerMessage.includes('cost') || lowerMessage.includes('estimate') || lowerMessage.includes('budget')) {
    return "I'll help you create a comprehensive cost analysis including SDTM/ADaM production, statistical analysis plans, interim analyses, and data transfers. The system will automatically calculate costs based on your protocol complexity. Let's get started - click 'Next'!";
  }
  
  // é€šç”¨å›å¤
  return "I understand you want to work on a clinical study project. I can help you with cost estimation, SDTM mapping, and data management planning. To get started, please click 'Next' to upload your protocol document, and I'll guide you through the entire process step by step.";
}

function showStep(step) {
  currentWizardStep = step;
  const pages = document.querySelectorAll('.wizard-page');
  pages.forEach(p => {
    const s = Number(p.getAttribute('data-step'));
    p.style.display = (s === step) ? 'block' : 'none';
  });
  
  const backBtn = document.getElementById('wizard-back-btn');
  const nextBtn = document.getElementById('wizard-next-btn');
  const navContainer = document.querySelector('.wizard-nav');
  
  if (step === 1) {
    // Step 1 (AI Assistant): éšè—æ‰€æœ‰å¯¼èˆªæŒ‰é’®ï¼Œå¼ºåˆ¶é€šè¿‡èŠå¤©äº¤äº’
    if (navContainer) navContainer.style.display = 'none';
  } else {
    // å…¶ä»–æ­¥éª¤ï¼šæ˜¾ç¤ºå¯¼èˆªæŒ‰é’®
    if (navContainer) navContainer.style.display = 'flex';
    backBtn.disabled = (step === 1);  // åªæœ‰Step 1ç¦ç”¨BackæŒ‰é’®
    nextBtn.disabled = false;
    nextBtn.querySelector('.ms-Button-label').textContent = (step === 6) ? 'Done' : 'Next';
  }
}



async function handleNext() {
  if (currentWizardStep === 1) {
    // Step1 â†’ Step2 (Upload)
    await cacheExcelState(1);
    showStep(2);
    return;
  }
  if (currentWizardStep === 2) {
    // Step2 (Upload) â†’ Step3 (Project Selection)
    await cacheExcelState(2);
    if (!window.currentDocumentId) {
      showStatusMessage('Please upload a protocol document before proceeding.', 'error');
      return;
    }
    showStep(3);
    return;
  }
  if (currentWizardStep === 3) {
    // Step3 (Project Selection) â†’ Step4 (Analysis Progress) â†’ åå°è§¦å‘åˆ†æ
    await cacheExcelState(3);
    if (window.currentDocumentId) {
      try { await saveProjectSelectionDetails(); } catch (e) { console.warn('ä¿å­˜é¡¹ç›®é€‰æ‹©å¤±è´¥ä½†ä¸é˜»å¡è¿›å…¥ä¸‹ä¸€æ­¥:', e); }
    }
    await createStandardCostAnalysisHeaders();
    await populateExcelWithSelectedProjects();

    // å¯åŠ¨åˆ†æï¼ˆæ˜¾ç¤ºåˆ†æè¿›åº¦é¡µï¼‰ï¼Œå®Œæˆåè¿›å…¥ç»“æœé¡µ
    if (!window.currentDocumentId) {
      showStatusMessage('Missing document id. Please upload again.', 'error');
      return;
    }
    showStep(4);
    try {
      const resp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/analyze-sdtm`, { method: 'POST' });
      const result = await resp.json();
      if (result?.success) {
        showStatusMessage('SDTM analysis completed.', 'success');
      } else {
        showStatusMessage('SDTM analysis failed or incomplete. You can review later.', 'error');
      }
    } catch (e) {
      console.warn('åˆ†æè§¦å‘å¤±è´¥:', e);
      showStatusMessage('Failed to start analysis. You can review later.', 'error');
    }

    // æ‹‰å–æœ€æ–°æ–‡æ¡£å†…å®¹å¹¶æ˜¾ç¤ºï¼ˆè‹¥æœ‰ï¼‰
    try {
      const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
      if (response.ok) {
        const docData = await response.json();
        const sdtmData = docData?.document?.sdtmData;
        if (sdtmData) {
          const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
            (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
            (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
          ));
          const source = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          if (source && source.procedures) {
            displaySDTMAnalysis(source);
          }
        }
      }
    } catch (e) { console.warn('è¿›å…¥SDTMç»“æœé¡µå‰è·å–SDTMå¤±è´¥:', e); }

    // Analysiså®Œæˆ â†’ è¿›å…¥ç»“æœé¡µï¼ˆStep5ï¼‰
    showStep(5);
    return;
  }
  if (currentWizardStep === 4) {
    // Step4 (Analysis Progress) â†’ Step5 (Results) 
    // å¦‚æœç”¨æˆ·åœ¨åˆ†æè¿›åº¦é¡µé¢ç‚¹å‡»Nextï¼Œç›´æ¥è·³è½¬åˆ°ç»“æœé¡µ
    await cacheExcelState(4);
    showStep(5);
    return;
  }
  if (currentWizardStep === 5) {
    // Step5 (Results) â†’ Step6 (Completion)
    await cacheExcelState(5);
    showStep(6);
    return;
  }
  if (currentWizardStep === 6) {
    // Step6 Doneï¼šæ ‡è®°æ•°æ®åº“ isCostEstimate = trueï¼Œä¿å­˜Excelï¼Œæ¸…ç©ºï¼Œå›åˆ°å¼€å§‹
    await cacheExcelState(6);
    if (!window.currentDocumentId) {
      showStatusMessage('Missing document id. Please upload again.', 'error');
      return;
    }
    try {
      const resp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/mark-complete`, { method: 'PATCH' });
      const result = await resp.json();
      if (result?.success) {
        showStatusMessage('Project completed! Saving Excel file and starting fresh...', 'success');
        
        // ä¿å­˜Excelåˆ°æœ¬åœ°
        await saveExcelToLocal();
        
        // æ¸…ç©ºExcelå†…å®¹
        await clearExcelContent();
        
        // é‡ç½®çŠ¶æ€å¹¶å›åˆ°å¼€å§‹é¡µ
        await resetToStart();
        
      } else {
        showStatusMessage('Failed to mark as completed: ' + (result?.message || ''), 'error');
      }
    } catch (err) {
      showStatusMessage('Failed to mark as completed: ' + err.message, 'error');
    }
  }
}

// åˆå§‹åŒ–æ—¶è°ƒç”¨
(function attachWizardInit(){
  const origOnReady = Office.onReady;
  // åœ¨ Office.onReady çš„å›è°ƒä¸­è°ƒç”¨ initWizardï¼ˆæ–‡ä»¶ä¸Šæ–¹å·²æœ‰ Office.onReadyï¼Œæˆ‘ä»¬ç›´æ¥åœ¨å…¶å†…éƒ¨ä¹Ÿè°ƒç”¨å³å¯ï¼‰
})();

async function checkAndOfferResume() {
  try {
    // 1) è‹¥å·²ç»‘å®š documentIdï¼Œä¼˜å…ˆç›´æ¥æ¢å¤
    const savedDocumentId = await loadDocumentIdFromSettings();
    if (savedDocumentId) {
      await restoreApplicationState(savedDocumentId);
      return; // å·²ç»‘å®šåˆ™æ— éœ€å¼¹çª—
    }

    // 2) æ‹‰å–æœªå®Œæˆåˆ—è¡¨
    const resp = await fetch(`${API_BASE_URL}/api/documents/incomplete-estimates`);
    const data = await resp.json();
    const list = Array.isArray(data?.data) ? data.data : [];

    // 3) å‡†å¤‡å¼¹çª—å…ƒç´ 
    const modal = document.getElementById('start-modal');
    const listEl = document.getElementById('incomplete-list');
    const btnNew = document.getElementById('start-new-btn');
    const btnContinue = document.getElementById('continue-selected-btn');
    const titleEl = document.getElementById('start-modal-title');
    const descEl = document.getElementById('start-modal-desc');

    let selectedId = null;

    // 4) æ ¹æ®æ˜¯å¦æœ‰æœªå®Œæˆé¡¹è°ƒæ•´æ–‡æ¡ˆä¸æŒ‰é’®
    if (list.length > 0) {
      titleEl.textContent = 'Welcome back';
      descEl.textContent = 'We found unfinished studies. Continue or start a new estimate?';
      btnContinue.style.display = '';
      btnContinue.setAttribute('disabled', 'true');
      listEl.classList.add('has-items');
      listEl.innerHTML = '';
      list.forEach(doc => {
        const div = document.createElement('div');
        div.className = 'item';
        const title = (doc.studyNumber && doc.studyNumber !== 'N/A') ? doc.studyNumber : '(No Study Number)';
        const subtitle = doc.originalName || '';
        const uploaded = doc.uploadedAt ? new Date(doc.uploadedAt).toLocaleString() : '';
        div.innerHTML = `
          <div class="check"></div>
          <div class="info">
            <div class="title">${title}</div>
            <div class="subtitle">${subtitle}</div>
            <div class="meta">Uploaded: ${uploaded}</div>
          </div>
        `;
        div.addEventListener('click', () => {
          Array.from(listEl.children).forEach(c => c.classList.remove('selected'));
          div.classList.add('selected');
          selectedId = doc._id;
          btnContinue.removeAttribute('disabled');
        });
        listEl.appendChild(div);
      });
    } else {
      titleEl.textContent = 'Start a New Cost Estimate?';
      descEl.textContent = 'No unfinished studies found. Would you like to start a new one?';
      btnContinue.style.display = 'none';
      listEl.classList.remove('has-items');
      listEl.innerHTML = '';
    }

    // 5) æ˜¾ç¤ºå¼¹çª—å¹¶ç»‘å®šæŒ‰é’®
    modal.style.display = 'flex';

    btnNew.onclick = () => {
      modal.style.display = 'none';
      showStep(1); // æ–°å¼€
    };
    btnContinue.onclick = async () => {
      if (!selectedId) { showStatusMessage('Please select a study to continue.', 'error'); return; }
      modal.style.display = 'none';
      await saveDocumentIdToSettings(selectedId);
      await restoreApplicationState(selectedId);
      showStep(3);
    };
  } catch (err) {
    console.warn('å¯åŠ¨æ—¶æ£€æŸ¥æœªå®Œæˆåˆ—è¡¨å¤±è´¥:', err);
    // å…œåº•ï¼šå¤±è´¥æ—¶ä¹Ÿç»™ç”¨æˆ·å¼€å§‹æ–°å»ºçš„é€‰æ‹©
    try {
      const modal = document.getElementById('start-modal');
      const listEl = document.getElementById('incomplete-list');
      const btnNew = document.getElementById('start-new-btn');
      const btnContinue = document.getElementById('continue-selected-btn');
      const titleEl = document.getElementById('start-modal-title');
      const descEl = document.getElementById('start-modal-desc');
      titleEl.textContent = 'Start a New Cost Estimate?';
      descEl.textContent = 'We could not check unfinished studies. You can still start a new one.';
      btnContinue.style.display = 'none';
      listEl.classList.remove('has-items');
      listEl.innerHTML = '';
      modal.style.display = 'flex';
      btnNew.onclick = () => { modal.style.display = 'none'; showStep(1); };
    } catch (_) {}
  }
}

// åœ¨ Office.onReady ä¸­ï¼Œåˆå§‹åŒ–åè°ƒç”¨
Office.onReady(async (info) => {
  if (info.host === Office.HostType.Excel) {
    document.getElementById("sideload-msg").style.display = "none";
    document.getElementById("app-body").style.display = "flex";
    
    initWizard();
    initFileUpload();
    initExcelChangeTracking(); // åˆå§‹åŒ–Excelå˜åŒ–ç›‘å¬

    // å…œåº•æ¢å¤ï¼šè‹¥æ–‡ä»¶è®¾ç½®å·²æœ‰documentIdï¼Œåœ¨æ¬¢è¿é¡µç›´æ¥æ¢å¤å¹¶è·³è½¬ç¬¬5æ­¥
    try {
      const savedDocumentId = await loadDocumentIdFromSettings();
      if (savedDocumentId) {
        await restoreApplicationState(savedDocumentId);
        showStep(5); // ç»“æœé¡µï¼ˆæ–°ç¼–å·ï¼‰
      } else {
        showStep(1);
      }
    } catch (error) {
      console.error('âŒ å¯åŠ¨æ—¶æ¢å¤çŠ¶æ€å¤±è´¥:', error);
      showStep(1);
    }
  }
});

// åˆå§‹åŒ–æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
function initFileUpload() {
  // Protocol upload
  const protocolSelectBtn = document.getElementById('protocol-select-btn');
  const protocolFileInput = document.getElementById('protocol-file-input');
  const protocolUploadArea = document.getElementById('protocol-upload-area');
  const protocolCancelBtn = document.getElementById('protocol-cancel-btn');
  const protocolRemoveBtn = document.getElementById('protocol-remove-btn');



  // Protocol upload events
  protocolSelectBtn.addEventListener('click', () => protocolFileInput.click());
  protocolUploadArea.addEventListener('click', () => protocolFileInput.click());
  protocolFileInput.addEventListener('change', (e) => handleProtocolUpload(e.target.files[0]));
  protocolCancelBtn.addEventListener('click', cancelProtocolUpload);
  protocolRemoveBtn.addEventListener('click', removeProtocolFile);

  // Drag and drop for protocol
  protocolUploadArea.addEventListener('dragover', handleDragOver);
  protocolUploadArea.addEventListener('drop', (e) => handleProtocolDrop(e));
  protocolUploadArea.addEventListener('dragenter', handleDragEnter);
  protocolUploadArea.addEventListener('dragleave', handleDragLeave);

  // ğŸ”¥ æ–°å¢ï¼šé¡¹ç›®é€‰æ‹©åŠ¨æ€è¾“å…¥æ¡†é€»è¾‘
  initProjectSelectionLogic();
  


}

// æ‹–æ‹½å¤„ç†å‡½æ•°
function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';
}

function handleDragEnter(e) {
  e.preventDefault();
  e.currentTarget.classList.add('dragover');
}

function handleDragLeave(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('dragover');
}

function handleProtocolDrop(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('dragover');
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    handleProtocolUpload(files[0]);
  }
}



// Protocolæ–‡ä»¶ä¸Šä¼ å¤„ç†ï¼ˆä»…å­˜å‚¨ï¼Œä¸è§¦å‘åˆ†æï¼Œä¹Ÿä¸ç«‹å³å¡«å……Excelï¼‰
async function handleProtocolUpload(file) {
  if (!file) return;

  const allowedTypes = [ 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ];
  if (!allowedTypes.includes(file.type)) {
    showStatusMessage('Please select PDF or Word documents only', 'error');
    return;
  }

  showProtocolProgress();
  try {
    const formData = new FormData();
    formData.append('document', file);
    formData.append('documentType', 'ClinicalProtocol');

    const response = await fetch(`${API_BASE_URL}/api/upload-document`, { method: 'POST', body: formData });
    if (!response.ok) { throw new Error(`Upload failed: ${response.statusText}`); }
    const result = await response.json();

    uploadedProtocol = { name: file.name, size: file.size, type: file.type, uploadId: result.uploadId };

    if (result.uploadId) {
      window.currentDocumentId = result.uploadId;
      await saveDocumentIdToSettings(result.uploadId);
    }

    showProtocolResult(file);
    showStatusMessage('Clinical Protocol uploaded. Click Next to select projects.', 'success');
  } catch (error) {
    console.error('Protocol upload error:', error);
    showStatusMessage(`Upload failed: ${error.message}`, 'error');
    hideProtocolProgress();
  }
}



// UIæ›´æ–°å‡½æ•°
function showProtocolProgress() {
  document.getElementById('protocol-upload-area').style.display = 'none';
  document.getElementById('protocol-progress').style.display = 'block';
  document.getElementById('protocol-result').style.display = 'none';
}

function hideProtocolProgress() {
  document.getElementById('protocol-upload-area').style.display = 'block';
  document.getElementById('protocol-progress').style.display = 'none';
}

function showProtocolResult(file) {
  document.getElementById('protocol-upload-area').style.display = 'none';
  document.getElementById('protocol-progress').style.display = 'none';
  document.getElementById('protocol-result').style.display = 'block';
  
  document.getElementById('protocol-file-name').textContent = file.name;
  document.getElementById('protocol-file-status').textContent = 'âœ… Clinical Protocol uploaded to MongoDB';
}

function cancelProtocolUpload() {
  hideProtocolProgress();
  showStatusMessage('Protocol upload cancelled', 'info');
  }

async function removeProtocolFile() {
  uploadedProtocol = null;
  window.currentDocumentId = null;
  currentSDTMData = null;
  
  document.getElementById('protocol-upload-area').style.display = 'block';
  document.getElementById('protocol-result').style.display = 'none';
  document.getElementById('protocol-file-input').value = '';
  
  // éšè—SDTMåˆ†æç»“æœ
  hideSDTMAnalysis();
  
  // ğŸ”¥ æ–°å¢ï¼šæ¸…é™¤Excelè®¾ç½®ä¸­çš„æŒä¹…åŒ–å­˜å‚¨
  await clearDocumentIdFromSettings();
  
  // é‡ç½®é¡¹ç›®é€‰æ‹©çŠ¶æ€
  const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
  checkboxes.forEach(checkbox => {
    checkbox.checked = false;
    const dataAttr = checkbox.getAttribute('data-requires-count');
    if (dataAttr) {
      const container = document.getElementById(`${dataAttr}-container`);
      const input = document.getElementById(`${dataAttr}-count`);
      if (container) container.style.display = 'none';
      if (input) input.value = '';
    }
  });
  
  showStatusMessage('Clinical Protocol removed', 'info');
}





// å·¥å…·å‡½æ•°
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function showStatusMessage(message, type) {
  const statusElement = document.getElementById('status-message');
  statusElement.textContent = message;
  statusElement.className = `status-message ${type}`;
  
  if (type === 'success' || type === 'info') {
    setTimeout(() => {
  statusElement.className = 'status-message';
    }, 3000);
  }
}

// ğŸ“ æŒä¹…åŒ–å­˜å‚¨å‡½æ•° - ç”¨äºåœ¨Excelæ–‡ä»¶ä¸­ä¿å­˜/æ¢å¤æ–‡æ¡£ID
async function saveDocumentIdToSettings(documentId) {
  try {
    await Excel.run(async (context) => {
      const settings = context.workbook.settings;
      
      // å°è¯•åˆ é™¤ç°æœ‰è®¾ç½®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      try {
        settings.getItem("currentDocumentId").delete();
      } catch (e) {
        // è®¾ç½®ä¸å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
      }
      
      // æ·»åŠ æ–°çš„è®¾ç½®
      settings.add("currentDocumentId", documentId);
      await context.sync();
      console.log('âœ… æ–‡æ¡£IDå·²ä¿å­˜åˆ°Excelè®¾ç½®:', documentId);
    });
  } catch (error) {
    console.error('âŒ ä¿å­˜æ–‡æ¡£IDå¤±è´¥:', error);
  }
}

async function loadDocumentIdFromSettings() {
  try {
    return await Excel.run(async (context) => {
      const settings = context.workbook.settings;
      const documentIdSetting = settings.getItem("currentDocumentId");
      context.load(documentIdSetting, "value");
      await context.sync();
      
      if (documentIdSetting.value) {
        console.log('âœ… ä»Excelè®¾ç½®ä¸­æ¢å¤æ–‡æ¡£ID:', documentIdSetting.value);
        return documentIdSetting.value;
      }
      return null;
    });
  } catch (error) {
    console.error('âŒ è¯»å–æ–‡æ¡£IDå¤±è´¥:', error);
    return null;
  }
}

async function clearDocumentIdFromSettings() {
  try {
    await Excel.run(async (context) => {
      context.workbook.settings.getItem("currentDocumentId").delete();
      await context.sync();
      console.log('âœ… å·²æ¸…é™¤Excelè®¾ç½®ä¸­çš„æ–‡æ¡£ID');
    });
  } catch (error) {
    console.error('âŒ æ¸…é™¤æ–‡æ¡£IDå¤±è´¥:', error);
  }
}

// ğŸ”„ çŠ¶æ€æ¢å¤å‡½æ•° - æ ¹æ®æ–‡æ¡£IDæ¢å¤æ‰€æœ‰ç•Œé¢çŠ¶æ€
async function restoreApplicationState(documentId) {
  try {
    window.currentDocumentId = documentId;
    showStatusMessage('Restoring data state...', 'info');
    
    // 1. è·å–æ–‡æ¡£æ•°æ®
    const response = await fetch(`${API_BASE_URL}/api/documents/${documentId}/content`);
    if (!response.ok) {
      throw new Error('Failed to fetch document data');
    }
    
    const docData = await response.json();
    if (!docData.success) {
      throw new Error(docData.message || 'Failed to get document content');
    }
    
    const document = docData.document;
    
    // 2. æ¢å¤SDTMæ•°æ®æ˜¾ç¤º
    if (document.sdtmData && (document.sdtmData.confirmed || document.sdtmData.original)) {
      const sdtmData = document.sdtmData.confirmed || document.sdtmData.original;
      if (sdtmData && sdtmData.procedures) {
        currentSDTMData = {
          success: true, // ç¡®ä¿ success ä¸º true
          procedures: sdtmData.procedures,
          mappings: sdtmData.mappings || [],
          summary: sdtmData.summary || {}
        };
        
        // æ˜¾ç¤ºSDTMåˆ†æç»“æœ
        displaySDTMAnalysis(currentSDTMData);
        showStatusMessage('SDTM analysis data restored', 'success');
      }
    }
    
    // 3. æ¢å¤é¡¹ç›®é€‰æ‹©çŠ¶æ€
    if (document.projectSelectionDetails) {
      restoreProjectSelections(document.projectSelectionDetails);
    }
    
    // 4. é‡æ–°å¡«å……Excelè¡¨æ ¼
    await createStandardCostAnalysisHeaders();
    await populateExcelWithSelectedProjects();
    
    // 4.1 æ¢å¤å·²ä¿å­˜çš„ Units/Costsï¼ˆä¼˜å…ˆä½¿ç”¨ç”¨æˆ·åœ¨Excelä¸­ä¿®æ”¹è¿‡çš„unitsï¼Œå…¶æ¬¡ä½¿ç”¨SDTMç¡®è®¤æ—¶çš„åˆå§‹å¿«ç…§ï¼‰
    try {
      const costEstimate = document?.costEstimate || {};
      if (costEstimate && typeof costEstimate === 'object') {
        if (costEstimate.units && Object.keys(costEstimate.units).length > 0) {
          console.log('ğŸ”„ æ¢å¤ç”¨æˆ·æœ€è¿‘åœ¨Excelä¿®æ”¹è¿‡çš„ Units åˆ°è¡¨æ ¼:', costEstimate.units);
          await applyUnitsToExcel(costEstimate.units);
        } else if (costEstimate['SDTM Datasets Production and Validation']) {
          console.log('ğŸ”„ ä½¿ç”¨SDTMç¡®è®¤æ—¶çš„å¿«ç…§æ¢å¤ Units/Costs');
          await applySDTMUnitsAndCostsToExcel(costEstimate['SDTM Datasets Production and Validation']);
        }
      }
    } catch (e) {
      console.warn('æ¢å¤Units/Costsåˆ°Excelæ—¶å‡ºç°é—®é¢˜:', e);
    }
    
    showStatusMessage('All data restored successfully!', 'success');
    
  } catch (error) {
    console.error('âŒ æ¢å¤åº”ç”¨çŠ¶æ€å¤±è´¥:', error);
    showStatusMessage('Failed to restore data: ' + error.message, 'error');
  }
}

// ğŸ¯ æ¢å¤é¡¹ç›®é€‰æ‹©çŠ¶æ€
function restoreProjectSelections(projectSelectionDetails) {
  try {
    // æ¸…é™¤æ‰€æœ‰ç°æœ‰çš„é€‰æ‹©
    const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      checkbox.checked = false;
      // éšè—ç›¸å…³çš„è®¡æ•°è¾“å…¥æ¡†
      const dataAttr = checkbox.getAttribute('data-requires-count');
      if (dataAttr) {
        const container = document.getElementById(`${dataAttr}-container`);
        if (container) {
          container.style.display = 'none';
        }
      }
    });
    
    // æ ¹æ®ä¿å­˜çš„æ•°æ®æ¢å¤é€‰æ‹©çŠ¶æ€
    Object.entries(projectSelectionDetails).forEach(([projectName, count]) => {
      if (projectName === 'lastUpdated') return;
      
      // æŸ¥æ‰¾å¯¹åº”çš„checkbox
      const checkbox = Array.from(checkboxes).find(cb => {
        const label = cb.nextElementSibling;
        if (label && label.classList.contains('ms-CheckBox-label')) {
          const textSpan = label.querySelector('.ms-CheckBox-text');
          return textSpan && textSpan.textContent.trim() === projectName;
        }
        return false;
      });
      
      if (checkbox) {
        checkbox.checked = true;
        
        // å¦‚æœæœ‰è®¡æ•°ä¿¡æ¯ï¼Œæ˜¾ç¤ºè¾“å…¥æ¡†å¹¶å¡«å……æ•°å€¼
        const dataAttr = checkbox.getAttribute('data-requires-count');
        if (dataAttr && count && count > 0) {
          const container = document.getElementById(`${dataAttr}-container`);
          const input = document.getElementById(`${dataAttr}-count`);
          if (container && input) {
            container.style.display = 'flex';
            input.value = count;
          }
        }
      }
    });
    
    console.log('âœ… é¡¹ç›®é€‰æ‹©çŠ¶æ€å·²æ¢å¤');
  } catch (error) {
    console.error('âŒ æ¢å¤é¡¹ç›®é€‰æ‹©çŠ¶æ€å¤±è´¥:', error);
  }
}

// å…¨å±€å˜é‡æ¥å­˜å‚¨å½“å‰çš„SDTMæ•°æ®å’ŒçŠ¶æ€
let currentSDTMData = null;
let isEditMode = false;
let selectedProcedureIndex = 0;

// SDTMåˆ†æç»“æœæ˜¾ç¤ºå‡½æ•°
function displaySDTMAnalysis(sdtmAnalysis) {
  console.log('æ˜¾ç¤ºSDTMåˆ†æç»“æœ:', sdtmAnalysis);
  
  // å­˜å‚¨å½“å‰æ•°æ®ï¼Œå¹¶ç¡®ä¿ success æœ‰åˆç†çš„é»˜è®¤
  const inferredSuccess = (sdtmAnalysis && (
    sdtmAnalysis.success === true ||
    (sdtmAnalysis.success === undefined && Array.isArray(sdtmAnalysis.procedures) && sdtmAnalysis.procedures.length > 0)
  ));

  currentSDTMData = {
    success: inferredSuccess === true,
    procedures: [...(sdtmAnalysis.procedures || [])],
    mappings: [...(sdtmAnalysis.mappings || [])],
    summary: { ...(sdtmAnalysis.summary || {}) }
  };
  
  const sdtmSection = document.getElementById('sdtm-analysis-section');
  const sdtmStatus = document.getElementById('sdtm-status');
  const sdtmStatusText = document.getElementById('sdtm-status-text');
  const sdtmMappingsContainer = document.getElementById('sdtm-mappings-container');
  
  // æ˜¾ç¤ºSDTMåˆ†æåŒºåŸŸ
  sdtmSection.style.display = 'block';
  
  const isOk = currentSDTMData.success === true;
  if (isOk) {
    // æ˜¾ç¤ºæˆåŠŸçŠ¶æ€
    sdtmStatus.style.display = 'block';
    sdtmStatus.className = 'sdtm-status success';
    sdtmStatusText.textContent = 'SDTM analysis completed successfully - Please review and confirm';
    
    // é‡æ–°è®¡ç®—æ­£ç¡®çš„å»é‡ç»Ÿè®¡æ•°æ®
    updateSummaryStats();
    
    // æ˜¾ç¤ºä¸»è¦çš„ç¼–è¾‘ç•Œé¢
    if (currentSDTMData.mappings && currentSDTMData.mappings.length > 0) {
      sdtmMappingsContainer.style.display = 'block';
      displayFlatMappingsList(currentSDTMData);
      setupSDTMEventListeners();
  } else {
      // å³ä¾¿æ²¡æœ‰ mappingsï¼Œä¹Ÿåº”æ˜¾ç¤ºæ‰€æœ‰ procedures çš„å¯ç¼–è¾‘ç©ºè¡Œ
      sdtmMappingsContainer.style.display = 'block';
      displayFlatMappingsList(currentSDTMData);
      setupSDTMEventListeners();
    }
    
  } else {
    // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
    sdtmStatus.style.display = 'block';
    sdtmStatus.className = 'sdtm-status error';
    sdtmStatusText.textContent = sdtmAnalysis.message || 'SDTM analysis failed';
  }
}

// æ›´æ–°ç»Ÿè®¡æ•°æ®å’ŒåŸŸæ¦‚è§ˆ
function updateSummaryAndDomainOverview(summary) {
  // æ›´æ–°ç»Ÿè®¡æ•°æ®
  document.getElementById('total-procedures').textContent = summary.total_procedures || 0;
  document.getElementById('total-domains').textContent = summary.total_sdtm_domains || 0;
  
  // æ›´æ–°åŸŸæ¦‚è§ˆ
  const domainsOverview = document.getElementById('domains-list-overview');
  domainsOverview.innerHTML = '';
  
  if (summary.unique_domains && summary.unique_domains.length > 0) {
    summary.unique_domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      domainsOverview.appendChild(domainTag);
    });
  }
  
  // æ›´æ–°é«˜å¤æ‚åº¦SDTM
  const highComplexityOverview = document.getElementById('high-complexity-domains');
  highComplexityOverview.innerHTML = '';
  
  if (summary.highComplexitySdtm && summary.highComplexitySdtm.domains && summary.highComplexitySdtm.domains.length > 0) {
    summary.highComplexitySdtm.domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      highComplexityOverview.appendChild(domainTag);
    });
  }
  
  // æ›´æ–°ä¸­å¤æ‚åº¦SDTM
  const mediumComplexityOverview = document.getElementById('medium-complexity-domains');
  mediumComplexityOverview.innerHTML = '';
  
  if (summary.mediumComplexitySdtm && summary.mediumComplexitySdtm.domains && summary.mediumComplexitySdtm.domains.length > 0) {
    summary.mediumComplexitySdtm.domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      mediumComplexityOverview.appendChild(domainTag);
    });
  }
}

// æ˜¾ç¤ºå¹³é“ºå¼æ˜ å°„åˆ—è¡¨
function displayFlatMappingsList(data) {
  const flatMappingsList = document.getElementById('flat-mappings-list');
  flatMappingsList.innerHTML = '';
  
  if (!data.procedures || data.procedures.length === 0) {
    flatMappingsList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No procedures found</div>';
    return;
  }
  
  // ğŸ”¥ é‡è¦æ”¹å˜ï¼šéå†æ‰€æœ‰proceduresï¼Œè€Œä¸æ˜¯åªéå†mappings
  data.procedures.forEach((procedure, index) => {
    // æŸ¥æ‰¾è¿™ä¸ªprocedureå¯¹åº”çš„mapping
    const mapping = data.mappings ? data.mappings.find(m => m.procedure === procedure) : null;
    
    // åˆ›å»ºæ˜ å°„å¯¹è±¡ï¼ˆå¦‚æœæ²¡æœ‰æ‰¾åˆ°mappingï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„ï¼‰
    const procedureMapping = {
      procedure: procedure,
      sdtm_domains: mapping ? mapping.sdtm_domains : []
    };
    
    const mappingRow = createMappingRow(procedureMapping, index);
    flatMappingsList.appendChild(mappingRow);
  });
}

// åˆ›å»ºå•ä¸ªæ˜ å°„è¡Œ
function createMappingRow(mapping, index) {
  const row = document.createElement('div');
  row.className = 'mapping-row';
  row.dataset.index = index;
  
  // Procedureåç§°
  const procedureName = document.createElement('div');
  procedureName.className = 'procedure-name';
  procedureName.textContent = mapping.procedure;
  
  // DomainsåŒºåŸŸ
  const domainsArea = document.createElement('div');
  domainsArea.className = 'domains-area';
  
  // æ·»åŠ ç°æœ‰çš„domainæ ‡ç­¾
  if (mapping.sdtm_domains && mapping.sdtm_domains.length > 0) {
    mapping.sdtm_domains.forEach((domain, domainIndex) => {
      const domainTag = createEditableDomainTag(domain, index, domainIndex);
      domainsArea.appendChild(domainTag);
    });
  }
  
  // æ·»åŠ "æ·»åŠ Domain"æŒ‰é’®
  const addBtn = document.createElement('div');
  addBtn.className = 'add-domain-btn';
  addBtn.innerHTML = '+ Add';
  addBtn.addEventListener('click', () => addNewDomain(index));
  domainsArea.appendChild(addBtn);
  
  row.appendChild(procedureName);
  row.appendChild(domainsArea);
  
  return row;
}

// åˆ›å»ºå¯ç¼–è¾‘çš„Domainæ ‡ç­¾
function createEditableDomainTag(domainText, mappingIndex, domainIndex) {
  const tag = document.createElement('span');
  tag.className = 'editable-domain-tag';
  tag.textContent = domainText;
  tag.dataset.mappingIndex = mappingIndex;
  tag.dataset.domainIndex = domainIndex;
  
  // åˆ é™¤æŒ‰é’®
  const removeBtn = document.createElement('span');
  removeBtn.className = 'remove-domain-btn';
  removeBtn.innerHTML = 'Ã—';
  removeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    removeDomain(mappingIndex, domainIndex);
  });
  tag.appendChild(removeBtn);
  
  // ç‚¹å‡»ç¼–è¾‘åŠŸèƒ½
  tag.addEventListener('click', () => {
    if (isEditMode) {
      makeTagEditable(tag);
    }
  });
  
  return tag;
}

// ä½¿æ ‡ç­¾è¿›å…¥å¯ç¼–è¾‘çŠ¶æ€
function makeTagEditable(tag) {
  if (tag.contentEditable === 'true') return; // å·²ç»åœ¨ç¼–è¾‘çŠ¶æ€
  
  const originalText = tag.textContent.replace('Ã—', '').trim();
  tag.innerHTML = originalText; // ç§»é™¤åˆ é™¤æŒ‰é’®
  tag.contentEditable = 'true';
  tag.classList.add('editing');
  tag.focus();
  
  // é€‰ä¸­æ‰€æœ‰æ–‡æœ¬
  const range = document.createRange();
  range.selectNodeContents(tag);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  
  // å¤„ç†ç¼–è¾‘å®Œæˆ
  const finishEditing = () => {
    tag.contentEditable = 'false';
    tag.classList.remove('editing');
    
    const newText = tag.textContent.trim();
    const mappingIndex = parseInt(tag.dataset.mappingIndex);
    const domainIndex = parseInt(tag.dataset.domainIndex);
    
    // æ›´æ–°æ•°æ®
    if (newText && currentSDTMData.mappings[mappingIndex]) {
      currentSDTMData.mappings[mappingIndex].sdtm_domains[domainIndex] = newText;
    }
    
    // é‡æ–°åˆ›å»ºæ ‡ç­¾ï¼ˆåŒ…å«åˆ é™¤æŒ‰é’®ï¼‰
    const newTag = createEditableDomainTag(newText, mappingIndex, domainIndex);
    tag.parentNode.replaceChild(newTag, tag);
    
    updateSummaryStats();
  };
  
  // ç›‘å¬äº‹ä»¶
  tag.addEventListener('blur', finishEditing);
  tag.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finishEditing();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      tag.textContent = originalText;
      finishEditing();
    }
  });
}

// åˆ é™¤Domain
function removeDomain(procedureIndex, domainIndex) {
  const procedureName = currentSDTMData.procedures[procedureIndex];
  if (!procedureName) return;
  
  // æŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹åº”çš„mapping
  let mapping = currentSDTMData.mappings.find(m => m.procedure === procedureName);
  if (mapping && mapping.sdtm_domains && mapping.sdtm_domains[domainIndex] !== undefined) {
    // ä»æ•°æ®ä¸­åˆ é™¤
    mapping.sdtm_domains.splice(domainIndex, 1);
    
    // é‡æ–°æ¸²æŸ“æ˜ å°„åˆ—è¡¨
    displayFlatMappingsList(currentSDTMData);
    
    // æ›´æ–°ç¼–è¾‘æ¨¡å¼æ˜¾ç¤º
    if (isEditMode) {
      toggleEditMode();
      toggleEditMode();
    }
    
    updateSummaryStats();
  }
}

// æ·»åŠ æ–°Domain
function addNewDomain(procedureIndex) {
  if (!isEditMode) return;
  
  const procedureName = currentSDTMData.procedures[procedureIndex];
  if (!procedureName) return;
  
  // æŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹åº”çš„mapping
  let mapping = currentSDTMData.mappings.find(m => m.procedure === procedureName);
  if (!mapping) {
    // å¦‚æœmappingä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
    mapping = {
      procedure: procedureName,
      sdtm_domains: []
    };
    currentSDTMData.mappings.push(mapping);
  }
  
  // æ·»åŠ ç©ºdomain
  mapping.sdtm_domains.push('');
  const newDomainIndex = mapping.sdtm_domains.length - 1;
  
  // é‡æ–°æ¸²æŸ“æ˜ å°„åˆ—è¡¨
  displayFlatMappingsList(currentSDTMData);
  
  // é‡æ–°è®¾ç½®ç¼–è¾‘æ¨¡å¼
  if (isEditMode) {
    toggleEditMode();
    toggleEditMode();
  }
  
  // æ‰¾åˆ°æ–°æ·»åŠ çš„æ ‡ç­¾å¹¶å¼€å§‹ç¼–è¾‘
  setTimeout(() => {
    const newTag = document.querySelector(`[data-mapping-index="${procedureIndex}"][data-domain-index="${newDomainIndex}"]`);
    if (newTag) {
      makeTagEditable(newTag);
    }
  }, 100);
}

// è®¾ç½®SDTMç›¸å…³çš„äº‹ä»¶ç›‘å¬å™¨
function setupSDTMEventListeners() {
  // ç¼–è¾‘æŒ‰é’®
  const editBtn = document.getElementById('edit-mappings-btn');
  if (editBtn) {
    editBtn.addEventListener('click', toggleEditMode);
  }
  
  // ç¡®è®¤æŒ‰é’®
  const confirmBtn = document.getElementById('confirm-mappings-btn');
  if (confirmBtn) {
    confirmBtn.addEventListener('click', confirmSDTMAnalysis);
  }
}

// åˆ‡æ¢ç¼–è¾‘æ¨¡å¼
function toggleEditMode() {
  isEditMode = !isEditMode;
  const editBtn = document.getElementById('edit-mappings-btn');
  const flatMappingsList = document.getElementById('flat-mappings-list');
  
  if (editBtn) {
    const btnLabel = editBtn.querySelector('.ms-Button-label');
    btnLabel.textContent = isEditMode ? 'View Mode' : 'Edit';
  }
  
  // æ›´æ–°å®¹å™¨çš„ç¼–è¾‘æ¨¡å¼æ ·å¼
  if (isEditMode) {
    flatMappingsList.classList.add('edit-mode');
    // ä¸ºæ‰€æœ‰æ˜ å°„è¡Œæ·»åŠ ç¼–è¾‘æ¨¡å¼æ ·å¼
    document.querySelectorAll('.mapping-row').forEach(row => {
      row.classList.add('edit-mode');
    });
  } else {
    flatMappingsList.classList.remove('edit-mode');
    // ç§»é™¤æ‰€æœ‰æ˜ å°„è¡Œçš„ç¼–è¾‘æ¨¡å¼æ ·å¼
    document.querySelectorAll('.mapping-row').forEach(row => {
      row.classList.remove('edit-mode');
    });
  }
}

// æ›´æ–°ç»Ÿè®¡æ•°æ®
function updateSummaryStats() {
  // åŸºäºåŸŸåšå»é‡ï¼Œå¹¶æŒ‰â€œHigh ä¼˜å…ˆçº§â€å½’ç±»ï¼Œç¡®ä¿äº’æ–¥
  const domainToComplexity = new Map(); // domain -> 'High' | 'Medium'

  if (Array.isArray(currentSDTMData.mappings)) {
    currentSDTMData.mappings.forEach(mapping => {
      const complexity = mapping && mapping.complexity === 'High' ? 'High' : 'Medium';
      const domains = Array.isArray(mapping?.sdtm_domains) ? mapping.sdtm_domains : [];
      domains.forEach(d => {
        const domain = (d || '').trim();
        if (!domain) return;
        const existing = domainToComplexity.get(domain);
        if (!existing) {
          domainToComplexity.set(domain, complexity);
        } else if (existing === 'Medium' && complexity === 'High') {
          // High è¦†ç›– Mediumï¼Œä¿è¯äº’æ–¥é›†åˆ
          domainToComplexity.set(domain, 'High');
        }
      });
    });
  }

  const allDomains = Array.from(domainToComplexity.keys());
  const highDomains = allDomains.filter(d => domainToComplexity.get(d) === 'High');
  const mediumDomains = allDomains.filter(d => domainToComplexity.get(d) === 'Medium');

  // æ›´æ–°summaryå¯¹è±¡ - ğŸ”¥ ç¡®ä¿proceduresæ•°é‡æ˜¯çœŸå®çš„
  currentSDTMData.summary.total_procedures = currentSDTMData.procedures ? currentSDTMData.procedures.length : 0;
  currentSDTMData.summary.unique_domains = allDomains;
  currentSDTMData.summary.total_sdtm_domains = allDomains.length;

  // æ›´æ–°å¤æ‚åº¦ç»Ÿè®¡ï¼ˆäº’æ–¥ï¼‰
  currentSDTMData.summary.highComplexitySdtm = {
    count: highDomains.length,
    domains: highDomains
  };
  currentSDTMData.summary.mediumComplexitySdtm = {
    count: mediumDomains.length,
    domains: mediumDomains
  };

  // æ›´æ–°æ˜¾ç¤º
  updateSummaryAndDomainOverview(currentSDTMData.summary);

  console.log('ç»Ÿè®¡æ•°æ®å·²æ›´æ–°:', {
    total_procedures: currentSDTMData.summary.total_procedures,
    total_sdtm_domains: currentSDTMData.summary.total_sdtm_domains,
    unique_domains: currentSDTMData.summary.unique_domains,
    highComplexitySdtm: currentSDTMData.summary.highComplexitySdtm,
    mediumComplexitySdtm: currentSDTMData.summary.mediumComplexitySdtm
  });
}

// ç¡®è®¤SDTMåˆ†æç»“æœ
async function confirmSDTMAnalysis() {
  if (!window.currentDocumentId) {
    alert('No document ID found. Please re-upload the document.');
    return;
  }
  if (!currentSDTMData || !Array.isArray(currentSDTMData.procedures)) {
    showStatusMessage('No SDTM data to confirm.', 'error');
    return;
  }
  
  try {
    console.log('å‘é€ç¡®è®¤è¯·æ±‚åˆ°æœåŠ¡å™¨...');
    
    const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/confirm-sdtm`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        procedures: currentSDTMData.procedures || [],
        mappings: currentSDTMData.mappings || [],
        summary: currentSDTMData.summary || {}
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log('SDTMåˆ†æå·²ç¡®è®¤å¹¶ä¿å­˜');
      
      // æ˜¾ç¤ºç¡®è®¤çŠ¶æ€
      const confirmationStatus = document.getElementById('confirmation-status');
      if (confirmationStatus) {
        confirmationStatus.style.display = 'flex';
      }
      
      // éšè—ç¼–è¾‘æŒ‰é’®ï¼Œæ˜¾ç¤ºå·²ç¡®è®¤çŠ¶æ€
      const editBtn = document.getElementById('edit-mappings-btn');
      const confirmBtn = document.getElementById('confirm-mappings-btn');
      if (editBtn) editBtn.style.display = 'none';
      if (confirmBtn) confirmBtn.style.display = 'none';
      
      showStatusMessage('SDTM analysis confirmed and saved successfully!', 'success');

      // â¬‡ï¸ æ ¹æ®è¿”å›çš„æˆæœ¬ä¼°ç®—å¿«ç…§ï¼Œå¡«å…¥Excelä¸­çš„ Unit ä¸ Estimated cost
      const costEstimate = result?.data?.costEstimate;
      let sdtmDataForNotes = null;
      if (costEstimate && costEstimate['SDTM Datasets Production and Validation']) {
        await applySDTMUnitsAndCostsToExcel(costEstimate['SDTM Datasets Production and Validation']);
      }

      // å…œåº•æ‹‰å–æ–‡æ¡£ï¼ˆç”¨äº Notes çš„åŸŸåˆ—è¡¨å†™å…¥ï¼‰
      try {
        const docResp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
        if (docResp.ok) {
          const docData = await docResp.json();
          const snapshot = docData?.document?.costEstimate?.['SDTM Datasets Production and Validation'];
          if (!costEstimate && snapshot) {
            await applySDTMUnitsAndCostsToExcel(snapshot);
          }
          const sdtmData = docData?.document?.sdtmData;
          if (sdtmData) {
            const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
              (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
              (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
            ));
            sdtmDataForNotes = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          }
        }
      } catch (e) {
        console.warn('æ— æ³•è·å–æ–‡æ¡£ç”¨äºå†™å…¥Notes:', e);
      }

      if (sdtmDataForNotes) {
        await applySDTMNotesToExcel(sdtmDataForNotes);
      }

    } else {
      console.error('ç¡®è®¤å¤±è´¥:', result.message);
      showStatusMessage('Failed to confirm SDTM analysis: ' + result.message, 'error');
    }
    
  } catch (error) {
    console.error('ç¡®è®¤è¯·æ±‚å¤±è´¥:', error);
    showStatusMessage('Network error: Failed to confirm SDTM analysis', 'error');
  }
}

// â¬‡ï¸ æ–°å¢ï¼šå°†SDTMçš„ units å’Œ estimatedCosts å†™å…¥Excelç›¸åº”è¡Œ
async function applySDTMUnitsAndCostsToExcel(snapshot) {
  const taskToKey = {
    'SDTM Annotated CRFs (aCRF)': 'annotatedCrf',
    'SDTM Dataset Specs (High Complexity)': 'specsHigh',
    'SDTM Dataset Specs (Medium Complexity)': 'specsMedium',
    'SDTM Production and Validation: Programs and Datasets (High Complexity)': 'prodHigh',
    'SDTM Production and Validation: Programs and Datasets (Medium Complexity)': 'prodMedium',
    'SDTM Pinnacle 21 Report Creation and Review': 'pinnacle21',
    "SDTM Reviewer's Guide": 'reviewersGuide',
    'SDTM Define.xml': 'defineXml',
    'SDTM Dataset File xpt Conversion and Review': 'xptConversion'
  };

  try {
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getActiveWorksheet();
      const used = sheet.getUsedRange();
      used.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();

      const startRow = used.rowIndex || 0;
      const startCol = used.columnIndex || 0;
      const rows = used.values;
      const units = snapshot.units || {};
      const costs = snapshot.estimatedCosts || {};
      const subtotal = snapshot.subtotal ?? null;

      // å†™æ¯ä¸ªå­é¡¹çš„ Unit å¹¶è®¾ç½® Estimated Cost å…¬å¼
      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (!taskToKey.hasOwnProperty(task)) continue;
        const key = taskToKey[task];
        const unitVal = units[key] ?? '';

        const unitCell = sheet.getRangeByIndexes(startRow + r, startCol + 1, 1, 1); // B
        const estCostCell = sheet.getRangeByIndexes(startRow + r, startCol + 5, 1, 1); // F
        
        // å†™å…¥Unitå€¼
        unitCell.values = [[unitVal === '' ? '' : Number(unitVal)]];
        unitCell.format.horizontalAlignment = 'Right';
        
        // è®¾ç½®Estimated Costå…¬å¼ = Cost Per Hour(C) Ã— Hours Per Unit(D)
        if (unitVal !== '') {
          const rowNum = startRow + r + 1; // Excelè¡Œå·ä»1å¼€å§‹
          estCostCell.formulas = [[`=C${rowNum}*D${rowNum}`]];
          estCostCell.format.numberFormat = [["$#,##0.00"]];
          estCostCell.format.horizontalAlignment = 'Right';
        } else {
          estCostCell.values = [['']];
        }
      }

      // å®šä½SDTMä¸»å—åçš„Subtotalè¡Œï¼Œå¹¶è®¾ç½®SUMå…¬å¼
      // æ‰¾åˆ°SDTMä¸»æ ‡é¢˜è¡Œ
      let sdtmStartRow = -1;
      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (task.toLowerCase() === 'sdtm datasets production and validation') {
          sdtmStartRow = r;
          break;
        }
      }
      if (sdtmStartRow >= 0) {
        // å‘ä¸‹å¯»æ‰¾ç¬¬ä¸€ä¸ªå€¼ä¸º 'Subtotal' çš„è¡Œ
        for (let r = sdtmStartRow + 1; r < rows.length; r++) {
          const firstCell = String(rows[r][0] || '').trim();
          if (firstCell.toLowerCase() === 'subtotal') {
            const subtotalCell = sheet.getRangeByIndexes(startRow + r, startCol + 5, 1, 1); // F
            
            // è®¾ç½®SUMå…¬å¼æ¥è‡ªåŠ¨è®¡ç®—SDTMéƒ¨åˆ†çš„å°è®¡
            const subtotalRowNum = startRow + r + 1; // Excelè¡Œå·ï¼ˆ1-basedï¼‰
            const sdtmSectionStartRow = startRow + sdtmStartRow + 2; // Excelè¡Œå·ï¼šæ ‡é¢˜ä¸‹ä¸€è¡Œ
            const sdtmSectionEndRow = subtotalRowNum - 1; // Excelè¡Œå·ï¼šSubtotalå‰ä¸€è¡Œ
            
            // ä»æ ‡é¢˜ä¸‹ä¸€è¡Œåˆ°Subtotalå‰ä¸€è¡Œï¼ˆé¿å…åŒ…å«Subtotalæœ¬èº«ï¼‰
            subtotalCell.formulas = [[`=SUM(F${sdtmSectionStartRow}:F${sdtmSectionEndRow})`]];
            subtotalCell.format.numberFormat = [["$#,##0.00"]];
            subtotalCell.format.horizontalAlignment = 'Right';
            subtotalCell.format.font.bold = true;
            break;
          }
        }
      }

      await context.sync();
      showStatusMessage('Units, estimated costs and subtotal applied from confirmed SDTM data.', 'success');
    });
  } catch (err) {
    console.error('Failed to write SDTM units and costs:', err);
    showStatusMessage('Failed to write units/costs/subtotal to Excel: ' + err.message, 'error');
  }
}

// â¬‡ï¸ å†™å…¥ SDTM Notesï¼ˆæ¥è‡ªæ•°æ®åº“çš„åŸŸåˆ—è¡¨ï¼‰
async function applySDTMNotesToExcel(sdtmInfo) {
  try {
    const highDomains = sdtmInfo?.summary?.highComplexitySdtm?.domains || [];
    const mediumDomains = sdtmInfo?.summary?.mediumComplexitySdtm?.domains || [];
    const allDomains = sdtmInfo?.summary?.unique_domains || [];

    const notesMap = {
      'SDTM Dataset Specs (High Complexity)': highDomains.join('/'),
      'SDTM Dataset Specs (Medium Complexity)': mediumDomains.join('/'),
      'SDTM Dataset File xpt Conversion and Review': allDomains.join('/'),
    };

    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getActiveWorksheet();
      const used = sheet.getUsedRange();
      used.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();

      const startRow = used.rowIndex || 0;
      const startCol = used.columnIndex || 0;
      const rows = used.values;

      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (!(task in notesMap)) continue;
        const note = notesMap[task] || '';
        const noteCell = sheet.getRangeByIndexes(startRow + r, startCol + 6, 1, 1); // åˆ—G Notes
        noteCell.values = [[note]];
        noteCell.format.horizontalAlignment = 'Left';
      }

      await context.sync();
      showStatusMessage('Notes updated from SDTM confirmed data.', 'success');
    });
  } catch (err) {
    console.error('Failed to write SDTM notes:', err);
    showStatusMessage('Failed to write SDTM notes: ' + err.message, 'error');
  }
}

// éšè—SDTMåˆ†æåŒºåŸŸï¼ˆåœ¨ç§»é™¤æ–‡ä»¶æ—¶è°ƒç”¨ï¼‰
function hideSDTMAnalysis() {
  const sdtmSection = document.getElementById('sdtm-analysis-section');
  const sdtmMappingsContainer = document.getElementById('sdtm-mappings-container');
  
  if (sdtmSection) {
    sdtmSection.style.display = 'none';
  }
  
  if (sdtmMappingsContainer) {
    sdtmMappingsContainer.style.display = 'none';
  }
  
  // é‡ç½®çŠ¶æ€
  currentSDTMData = null;
  window.currentDocumentId = null;
  isEditMode = false;
  selectedProcedureIndex = 0;
}

// ä¿å­˜Excelåˆ°æœ¬åœ°
async function saveExcelToLocal() {
  try {
    await Excel.run(async (context) => {
      const workbook = context.workbook;
      
      // ç”Ÿæˆæ–‡ä»¶å
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const fileName = `LLX_Cost_Analysis_${timestamp}.xlsx`;
      
      // ä¿å­˜å·¥ä½œç°¿
      workbook.save();
      await context.sync();
      
      console.log('âœ… Excelæ–‡ä»¶å·²ä¿å­˜:', fileName);
      showStatusMessage('Excel file saved successfully!', 'success');
    });
  } catch (error) {
    console.error('âŒ ä¿å­˜Excelå¤±è´¥:', error);
    showStatusMessage('Failed to save Excel: ' + error.message, 'error');
  }
}

// æ¸…ç©ºExcelå†…å®¹
async function clearExcelContent() {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // è·å–å·²ä½¿ç”¨èŒƒå›´
      const usedRange = worksheet.getUsedRange();
      if (usedRange) {
        usedRange.clear();
        await context.sync();
      }
      
      console.log('âœ… Excelå†…å®¹å·²æ¸…ç©º');
      showStatusMessage('Excel content cleared for new project!', 'success');
    });
  } catch (error) {
    console.error('âŒ æ¸…ç©ºExcelå¤±è´¥:', error);
    showStatusMessage('Failed to clear Excel: ' + error.message, 'error');
  }
}

// é‡ç½®åˆ°å¼€å§‹çŠ¶æ€
async function resetToStart() {
  try {
    // æ¸…é™¤çŠ¶æ€å˜é‡
    uploadedProtocol = null;
    window.currentDocumentId = null;
    currentSDTMData = null;
    isEditMode = false;
    selectedProcedureIndex = 0;
    
    // æ¸…é™¤Excelè®¾ç½®
    await clearDocumentIdFromSettings();
    
    // é‡ç½®é¡¹ç›®é€‰æ‹©çŠ¶æ€
    const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      checkbox.checked = false;
      const dataAttr = checkbox.getAttribute('data-requires-count');
      if (dataAttr) {
        const container = document.getElementById(`${dataAttr}-container`);
        const input = document.getElementById(`${dataAttr}-count`);
        if (container) container.style.display = 'none';
        if (input) input.value = '';
      }
    });
    
    // é‡ç½®ä¸Šä¼ ç•Œé¢
    document.getElementById('protocol-upload-area').style.display = 'block';
    document.getElementById('protocol-progress').style.display = 'none';
    document.getElementById('protocol-result').style.display = 'none';
    document.getElementById('protocol-file-input').value = '';
    
    // éšè—SDTMåˆ†æ
    hideSDTMAnalysis();
    
    // ğŸ”¥ é‡ç½®AIåŠ©æ‰‹èŠå¤©è®°å½•
    resetAIChatInterface();
    
    // å›åˆ°ç¬¬1æ­¥
    showStep(1);
    
    console.log('âœ… åº”ç”¨çŠ¶æ€å·²é‡ç½®');
    showStatusMessage('Ready for new project!', 'success');
    
  } catch (error) {
    console.error('âŒ é‡ç½®çŠ¶æ€å¤±è´¥:', error);
    showStatusMessage('Failed to reset: ' + error.message, 'error');
  }
}

// ğŸ”¥ æ–°å¢ï¼šè‡ªåŠ¨åˆ›å»ºæ ‡å‡†æˆæœ¬åˆ†æè¡¨æ ¼æ ‡é¢˜
async function createStandardCostAnalysisHeaders() {
  try {
    await Excel.run(async (context) => {
      // è·å–å½“å‰æ´»åŠ¨çš„å·¥ä½œè¡¨
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // å®šä¹‰æ ‡å‡†çš„åˆ—æ ‡é¢˜
      const headers = [
        "Task",
        "Unit", 
        "Cost Per Hour",
        "# of Hours Per Unit",
        "Cost Per Unit",
        "Estimated cost",
        "Notes"
      ];
      
      // è·å–ç¬¬ä¸€è¡Œçš„èŒƒå›´ï¼ˆA1:G1ï¼‰
      const headerRange = worksheet.getRange("A1:G1");
      
      // è®¾ç½®æ ‡é¢˜å€¼
      headerRange.values = [headers];
      
      // è®¾ç½®æ ¼å¼ï¼šç²—ä½“
      headerRange.format.font.bold = true;
      
      // å¯é€‰ï¼šè®¾ç½®å…¶ä»–æ ¼å¼
      headerRange.format.font.size = 12;
      headerRange.format.fill.color = "#E7E7E7"; // æµ…ç°è‰²èƒŒæ™¯
      headerRange.format.borders.getItem("EdgeTop").style = "Continuous";
      headerRange.format.borders.getItem("EdgeBottom").style = "Continuous";
      headerRange.format.borders.getItem("EdgeLeft").style = "Continuous";
      headerRange.format.borders.getItem("EdgeRight").style = "Continuous";
      headerRange.format.borders.getItem("InsideVertical").style = "Continuous";
      
      // è‡ªåŠ¨è°ƒæ•´åˆ—å®½
      headerRange.format.autofitColumns();

      await context.sync();
      
      console.log('âœ… æ ‡å‡†æˆæœ¬åˆ†æè¡¨æ ¼æ ‡é¢˜å·²åˆ›å»º');
      showStatusMessage('Excel table headers created successfully!', 'success');
    });
  } catch (error) {
    console.error('âŒ åˆ›å»ºExcelæ ‡é¢˜æ—¶å‡ºé”™:', error);
    showStatusMessage('Failed to create Excel headers: ' + error.message, 'error');
  }
}

// ğŸ”¥ æ–°å¢ï¼šæ ¹æ®é¡¹ç›®é€‰æ‹©å¡«å†™Excelä»»åŠ¡åˆ—è¡¨ï¼ˆä¸Šä¼ æ—¶ä»…ç”Ÿæˆæ¡†æ¶ï¼Œä¸å†™Unit/Estimated costï¼‰
async function populateExcelWithSelectedProjects() {
  try {
    // ä»MongoDBè·å–å·²ä¿å­˜çš„é¡¹ç›®é€‰æ‹©è¯¦æƒ…å’ŒSDTMæ•°æ®
    let savedProjectDetails = {};
    let sdtmInfo = null;
    if (window.currentDocumentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
        if (response.ok) {
          const docData = await response.json();
          if (docData.document && docData.document.projectSelectionDetails) {
            savedProjectDetails = docData.document.projectSelectionDetails;
          }
          // è·å–SDTMæ•°æ®ï¼ˆæ­¤å¤„ä»…ç”¨äºå±•ç¤ºï¼Œä¸ç”¨äºå†™Unitï¼‰
          if (docData.document && docData.document.sdtmData) {
            const sdtmData = docData.document.sdtmData;
            const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
              (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
              (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
            ));
            sdtmInfo = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          }
        }
      } catch (error) {
        console.warn('æ— æ³•è·å–å·²ä¿å­˜çš„é¡¹ç›®è¯¦æƒ…ï¼Œä½¿ç”¨å½“å‰é€‰æ‹©:', error);
      }
    }
    
    if (Object.keys(savedProjectDetails).length === 0) {
      const { projectSelectionDetails } = collectProjectSelectionDetails();
      savedProjectDetails = projectSelectionDetails;
    }

    const highComplexityCount = sdtmInfo?.summary?.highComplexitySdtm?.count || 0;
    const mediumComplexityCount = sdtmInfo?.summary?.mediumComplexitySdtm?.count || 0;
    const totalDomainsCount = sdtmInfo?.summary?.total_sdtm_domains || 0;

    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      let currentRow = 2;

      if (Object.keys(savedProjectDetails).length > 0) {
        for (const [projectName, count] of Object.entries(savedProjectDetails)) {
          if (projectName === 'lastUpdated') continue;

          const isSDTM = projectName.toLowerCase().includes("sdtm");
          const isADAM = projectName.toLowerCase().includes("adam");
          const isDSUR = projectName.toLowerCase().includes("dsur");
          const isDSMB = projectName.toLowerCase().includes("dsmb");
          const isStatisticalAnalysisPlan = projectName.toLowerCase().includes("statistical analysis plan");

          if (isSDTM || isADAM || isStatisticalAnalysisPlan) {
            const projectNameRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            projectNameRange.values = [[projectName, "", "", "", "", "", ""]];
            projectNameRange.format.font.bold = true;
            projectNameRange.format.horizontalAlignment = "Left";
            currentRow++;
            const sectionTitleRow = currentRow - 1; // è®°å½•åˆ†èŠ‚æ ‡é¢˜æ‰€åœ¨è¡Œï¼ˆç”¨äºè®¡ç®—SubtotalèŒƒå›´ï¼‰

            if (isSDTM) {
              const sdtmSubItems = [
                { name: "SDTM Annotated CRFs (aCRF)", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Dataset Specs (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 3, costPerUnit: 3.0 },
                { name: "SDTM Dataset Specs (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 2, costPerUnit: 2.0 },
                { name: "SDTM Production and Validation: Programs and Datasets (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 16, costPerUnit: 16.0 },
                { name: "SDTM Production and Validation: Programs and Datasets (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 10, costPerUnit: 10.0 },
                { name: "SDTM Pinnacle 21 Report Creation and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 6, costPerUnit: 6.0 },
                { name: "SDTM Reviewer's Guide", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Define.xml", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Dataset File xpt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 }
              ];

              for (const subItem of sdtmSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[
                  subItem.name,
                  "", // Unit ç•™ç©ºï¼Œå¾…ç¡®è®¤åå¡«å…¥
                  `$${subItem.costPerHour}`,
                  subItem.hoursPerUnit,
                  `$${subItem.costPerUnit}`,
                  "", // Estimated Cost ç•™ç©ºï¼Œå°†ç”¨å…¬å¼è®¡ç®—
                  ""
                ]];
                
                // ä¸ºEstimated Coståˆ—(F)è®¾ç½®Excelå…¬å¼ï¼š=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            } else if (isADAM) {
              // ADAM ä¿æŒåŸæœ‰å ä½ï¼ˆUnit ç•™ç©ºï¼‰
              const adamSubItems = [
                { name: "ADaM Dataset Specs (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 3, costPerUnit: 3.0 },
                { name: "ADaM Dataset Specs (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 2, costPerUnit: 2.0 },
                { name: "ADaM Production and Validation: Programs and Datasets (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 18, costPerUnit: 18.0 },
                { name: "ADaM Production and Validation: Programs and Datasets (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 10, costPerUnit: 10.0 },
                { name: "ADaM Pinnacle 21 Report Creation and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 4, costPerUnit: 4.0 },
                { name: "ADaM Reviewer's Guide", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "ADaM Define.xml", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "ADaM Dataset Program xpt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 },
                { name: "ADaM Program txt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 }
              ];

              for (const subItem of adamSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[
                  subItem.name,
                  "",
                  `$${subItem.costPerHour}`,
                  subItem.hoursPerUnit,
                  `$${subItem.costPerUnit}`,
                  "",
                  ""
                ]];
                
                // ä¸ºEstimated Coståˆ—(F)è®¾ç½®Excelå…¬å¼ï¼š=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            } else if (isStatisticalAnalysisPlan) {
              const sapSubItems = [
                { name: "Statistical Analysis Plan Draft 1", unit: "", costPerHour: 1.0, hoursPerUnit: 40, costPerUnit: 40.0 },
                { name: "Statistical Analysis Plan Draft 2", unit: "", costPerHour: 1.0, hoursPerUnit: 30, costPerUnit: 30.0 },
                { name: "Statistical Analysis Plan Final", unit: "", costPerHour: 1.0, hoursPerUnit: 20, costPerUnit: 20.0 },
                { name: "Analysis Shells Development", unit: "", costPerHour: 1.0, hoursPerUnit: 60, costPerUnit: 60.0 },
                { name: "Mock Tables, Listings, and Figures", unit: "", costPerHour: 1.0, hoursPerUnit: 40, costPerUnit: 40.0 }
              ];
              for (const subItem of sapSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[subItem.name, "", `$${subItem.costPerHour}`, subItem.hoursPerUnit, `$${subItem.costPerUnit}`, "", ""]];
                
                // ä¸ºEstimated Coståˆ—(F)è®¾ç½®Excelå…¬å¼ï¼š=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            }

            // Subtotal for main section with Excel SUM formula
            const mainSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            mainSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
            
            // è®¡ç®—å½“å‰éƒ¨åˆ†çš„å¼€å§‹è¡Œï¼ˆé¡¹ç›®æ ‡é¢˜è¡Œ+1ï¼‰å’Œç»“æŸè¡Œï¼ˆå½“å‰è¡Œ-1ï¼‰
            // ä¿®æ­£ï¼šsectionStartRow = é¡¹ç›®æ ‡é¢˜è¡Œçš„ä¸‹ä¸€è¡Œï¼›
            // ç”±äºæˆ‘ä»¬æ¯æ¬¡è¿›å…¥è¯¥åˆ†èŠ‚æ—¶å…ˆå†™äº†æ ‡é¢˜å¹¶ currentRow++ï¼Œéšåå†™äº†Nä¸ªå­é¡¹ï¼Œå†åˆ°æ­¤å¤„å†™Subtotalï¼Œ
            // æ­¤æ—¶ currentRow æŒ‡å‘Subtotalè¡Œï¼Œå› æ­¤ï¼š
            //   sectionEndRow = currentRow - 1ï¼ˆæœ€åä¸€ä¸ªå­é¡¹ï¼‰
            //   sectionStartRow = sectionEndRow - (å­é¡¹æ•°é‡ - 1)
            // è¿™é‡Œä¸å†ç”¨ç¡¬ç¼–ç æ•°é‡ï¼Œæ”¹ä¸ºä»æ ‡é¢˜è¡Œç¼“å­˜ï¼š
            const subtotalRow = currentRow;
            const lastItemRow = subtotalRow - 1;
            const firstItemRow = (isSDTM || isADAM || isStatisticalAnalysisPlan) ? (sectionTitleRow + 1) : (sectionTitleRow + 1);
            
            // ä¸ºSubtotalçš„Fåˆ—è®¾ç½®SUMå…¬å¼
            const subtotalCell = worksheet.getRange(`F${currentRow}`);
            subtotalCell.formulas = [[`=SUM(F${firstItemRow}:F${lastItemRow})`]];
            subtotalCell.format.numberFormat = [["$#,##0.00"]];
            subtotalCell.format.font.bold = true;
            
            mainSubtotalRange.format.font.bold = true;
            mainSubtotalRange.format.horizontalAlignment = "Right";
            currentRow++;

            // Transfer blocks remain unchanged
            if (count && count > 0 && (isSDTM || isADAM)) {
              const transferSubsection = isSDTM ? `SDTM Dataset Transfer (${count} times)` : `ADAM Dataset Transfer (${count} times)`;
              const transferRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              transferRange.values = [[transferSubsection, "", "", "", "", "", ""]];
              transferRange.format.font.bold = true;
              transferRange.format.horizontalAlignment = "Left";
              currentRow++;

              const transferSubItems = isSDTM ? [
                { name: `Production and Validation, the first 2 times`, unit: 2, costPerHour: 1.0, hoursPerUnit: 25, costPerUnit: 25.0 },
                { name: `Production and Validation, the last ${count - 2} times`, unit: count - 2, costPerHour: 1.0, hoursPerUnit: 12.5, costPerUnit: 12.5 }
              ] : [
                { name: `Production and Validation, the first 2 times`, unit: 2, costPerHour: 1.0, hoursPerUnit: 15, costPerUnit: 15.0 },
                { name: `Production and Validation, the last ${count - 2} times`, unit: count - 2, costPerHour: 1.0, hoursPerUnit: 7.5, costPerUnit: 7.5 }
              ];
              for (const transferSubItem of transferSubItems) {
                const transferSubItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                transferSubItemRange.values = [[transferSubItem.name, "", `$${transferSubItem.costPerHour}`, transferSubItem.hoursPerUnit, `$${transferSubItem.costPerUnit}`, "", ""]];
                transferSubItemRange.format.font.bold = false;
                transferSubItemRange.format.horizontalAlignment = "Left";
                const transferNumberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                transferNumberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
              const transferSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              transferSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
              transferSubtotalRange.format.font.bold = true;
              transferSubtotalRange.format.horizontalAlignment = "Right";
              currentRow++;
            }

          } else if (isDSUR || isDSMB) {
            if (count && count > 0) {
              const rerunSubsection = isDSUR ? `DSUR Rerun (${count} times)` : `DSMB Rerun (${count} times)`;
              const rerunRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              rerunRange.values = [[rerunSubsection, "", "", "", "", "", ""]];
              rerunRange.format.font.bold = true;
              rerunRange.format.horizontalAlignment = "Left";
              currentRow++;
              const rerunSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              rerunSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
              rerunSubtotalRange.format.font.bold = true;
              rerunSubtotalRange.format.horizontalAlignment = "Right";
              currentRow++;
            }
          } else {
            const projectNameRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            projectNameRange.values = [[projectName, "", "", "", "", "", ""]];
            projectNameRange.format.font.bold = true;
            projectNameRange.format.horizontalAlignment = "Left";
            currentRow++;
            const subtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            subtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
            subtotalRange.format.font.bold = true;
            subtotalRange.format.horizontalAlignment = "Right";
            currentRow++;
          }
        }
      }

      // é»˜è®¤æœ«å°¾ä¸‰éƒ¨åˆ†
      const defaultSections = [
        'License Fees',
        'Adhoc Analysis',
        'Project Management/Administration(12 Months)'
      ];
      for (const sectionName of defaultSections) {
        const range = worksheet.getRange(`A${currentRow}:G${currentRow}`);
        range.values = [[sectionName, "", "", "", "", "", ""]];
        range.format.font.bold = true;
        range.format.horizontalAlignment = 'Left';
        currentRow++;
        const subtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
        subtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
        subtotalRange.format.font.bold = true;
        subtotalRange.format.horizontalAlignment = 'Right';
        currentRow++;
      }

      // Grand Total
      const grandTotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
      grandTotalRange.values = [["Grand Total", "", "", "", "", "", ""]];
      grandTotalRange.format.font.bold = true;
      grandTotalRange.format.horizontalAlignment = 'Right';
    });
  } catch (error) {
    console.error('å¡«å……Excelä»»åŠ¡åˆ—è¡¨å¤±è´¥:', error);
    showStatusMessage('Failed to populate Excel: ' + error.message, 'error');
  }
}

// ğŸ”¥ æ–°å¢ï¼šé¡¹ç›®é€‰æ‹©åŠ¨æ€è¾“å…¥æ¡†é€»è¾‘
function initProjectSelectionLogic() {
  // è·å–æ‰€æœ‰éœ€è¦åŠ¨æ€è¾“å…¥æ¡†çš„checkbox
  const checkboxesWithCounts = document.querySelectorAll('[data-requires-count]');
  
  checkboxesWithCounts.forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      const countType = this.getAttribute('data-requires-count');
      const container = document.getElementById(`${countType}-container`);
      
      if (container) {
        if (this.checked) {
          // æ˜¾ç¤ºè¾“å…¥æ¡†
          container.style.display = 'flex';
          // èšç„¦åˆ°è¾“å…¥æ¡†
          const input = container.querySelector('.count-input');
          if (input) {
            setTimeout(() => input.focus(), 300);
          }
        } else {
          // éšè—è¾“å…¥æ¡†å¹¶æ¸…ç©ºå€¼
          container.style.display = 'none';
          const input = container.querySelector('.count-input');
          if (input) {
            input.value = '';
          }
        }
      }
    });
  });
}

// ğŸ”¥ æ–°å¢ï¼šæ”¶é›†é¡¹ç›®é€‰æ‹©è¯¦ç»†ä¿¡æ¯ (ç®€åŒ–æ ¼å¼: é¡¹ç›®å->æ¬¡æ•°)
function collectProjectSelectionDetails() {
  const projectSelectionDetails = {};
  
  // æ”¶é›†æ‰€æœ‰å‹¾é€‰çš„é¡¹ç›®å’Œå¯¹åº”çš„æ¬¡æ•°
  const allCheckboxes = document.querySelectorAll('.ms-CheckBox-input');
  allCheckboxes.forEach((checkbox) => {
    if (checkbox.checked) {
      const projectName = checkbox.parentElement.querySelector('.ms-CheckBox-text').textContent.trim();
      
      // æ ¹æ®é¡¹ç›®ç±»å‹è·å–å¯¹åº”çš„æ•°é‡è¾“å…¥æ¡†
      let count = null;
      const requiresCount = checkbox.getAttribute('data-requires-count');
      
      if (requiresCount) {
        const countInput = document.getElementById(`${requiresCount}-count`);
        if (countInput && countInput.value) {
          count = parseInt(countInput.value);
        }
      }
      
      // ç›´æ¥å­˜å‚¨: "é¡¹ç›®å": æ¬¡æ•° (æ²¡æœ‰æ¬¡æ•°åˆ™ä¸ºnull)
      projectSelectionDetails[projectName] = count;
    }
  });
  
  return {
    projectSelectionDetails
  };
}

// ğŸ”¥ æ–°å¢ï¼šä¿å­˜é¡¹ç›®é€‰æ‹©è¯¦ç»†ä¿¡æ¯åˆ°åç«¯
async function saveProjectSelectionDetails() {
  try {
    if (!window.currentDocumentId) {
      console.warn('æ²¡æœ‰å½“å‰æ–‡æ¡£IDï¼Œè·³è¿‡ä¿å­˜é¡¹ç›®é€‰æ‹©è¯¦æƒ…');
      return;
    }
    
    const { projectSelectionDetails } = collectProjectSelectionDetails();
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é¡¹ç›®é€‰æ‹©
    if (Object.keys(projectSelectionDetails).length === 0) {
      console.log('æ²¡æœ‰é¡¹ç›®é€‰æ‹©ï¼Œè·³è¿‡ä¿å­˜');
      return;
    }
    
    const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/project-selection`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ projectSelectionDetails })
    });
    
    if (response.ok) {
      console.log('âœ… é¡¹ç›®é€‰æ‹©è¯¦æƒ…å·²è‡ªåŠ¨ä¿å­˜');
      showStatusMessage('Project selection automatically saved with document!', 'success');
    } else {
      throw new Error('ä¿å­˜é¡¹ç›®é€‰æ‹©è¯¦æƒ…å¤±è´¥');
    }
    
  } catch (error) {
    console.error('âŒ ä¿å­˜é¡¹ç›®é€‰æ‹©è¯¦æƒ…æ—¶å‡ºé”™:', error);
    // ä¸æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼Œå› ä¸ºè¿™æ˜¯è‡ªåŠ¨ä¿å­˜ï¼Œä¸åº”è¯¥å¹²æ‰°ç”¨æˆ·ä½“éªŒ
  }
}




