/*
 * Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
 * See LICENSE in the project root for license information.
 */

/* global console, document, Excel, Office */

// 后端API基础URL - 使用HTTPS避免混合内容问题
const API_BASE_URL = 'https://localhost:4000';

// 全局变量
let uploadedProtocol = null;

// Excel状态缓存系统 - 用于Back导航时恢复Excel内容
let excelStateCache = {
  step1: null,   // AI Assistant (空白状态)
  step2: null,   // Upload完成后（通常对Excel无改动）
  step3: null,   // Project Selection完成后 + Excel Headers
  step4: null,   // Analysis Progress（占位）
  step5: null,   // SDTM Analysis结果页
  step6: null    // 完成确认页（占位）
};

// 🔄 Excel变化监听和数据同步
let isTrackingChanges = false;
let changeTimeout = null;

async function initExcelChangeTracking() {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // 监听单元格变化事件（使用事件参数的 address/worksheetId 获取 Range）
      worksheet.onChanged.add(async (args) => {
        try {
          await Excel.run(async (innerContext) => {
            const sheet = innerContext.workbook.worksheets.getItem(args.worksheetId);
            const changedRange = sheet.getRange(args.address);
            changedRange.load([ 'columnIndex', 'columnCount' ]);
            await innerContext.sync();
            
            // 是否包含B列？
            const startCol = changedRange.columnIndex; // 0-based
            const endCol = startCol + changedRange.columnCount - 1;
            const includesB = (startCol <= 1 && endCol >= 1);
            if (!includesB) return;
            
            // 防抖保存
            if (changeTimeout) { clearTimeout(changeTimeout); }
            changeTimeout = setTimeout(async () => {
              await saveExcelChangesToDatabase();
            }, 1000);
          });
        } catch (err) {
          console.error('❌ Excel onChanged 处理失败:', err);
        }
      });
      
      await context.sync();
      console.log('✅ Excel变化监听已启用');
    });
  } catch (error) {
    console.error('❌ 初始化Excel变化监听失败:', error);
  }
}


async function saveExcelChangesToDatabase() {
  if (!window.currentDocumentId) {
    console.warn('⚠️ 没有有效的文档ID，跳过保存');
    return;
  }
  
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      const usedRange = worksheet.getUsedRange();
      usedRange.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();
      
      const rows = usedRange.values;
      const updatedUnits = {};
      
      // 提取所有Unit值（B列）
      for (let r = 0; r < rows.length; r++) {
        const taskName = String(rows[r][0] || '').trim();
        const unitValue = rows[r][1]; // B列
        
        if (taskName && unitValue !== undefined && unitValue !== '') {
          // 映射任务名称到key
          const taskKey = getTaskKeyFromName(taskName);
          if (taskKey) {
            updatedUnits[taskKey] = Number(unitValue) || 0;
          }
        }
      }
      
      // 发送到后端保存（可并发更新）
      const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/update-units`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ units: updatedUnits })
      });
      
      const result = await response.json();
      if (result.success) {
        console.log('✅ Excel Unit变化已同步到数据库');
        showStatusMessage('Units updated and saved automatically!', 'success');
      } else {
        console.warn('⚠️ 保存Unit变化失败:', result.message);
      }
    });
  } catch (error) {
    console.error('❌ 保存Excel变化到数据库失败:', error);
    showStatusMessage('Failed to save changes: ' + error.message, 'error');
  }
}

// 辅助函数：从任务名称获取对应的key
function getTaskKeyFromName(taskName) {
  const taskMapping = {
    // SDTM family (match the exact row titles we render in Excel)
    'SDTM Annotated CRFs (aCRF)': 'annotatedCrf',
    'SDTM Dataset Specs (High Complexity)': 'specsHigh',
    'SDTM Dataset Specs (Medium Complexity)': 'specsMedium',
    'SDTM Production and Validation: Programs and Datasets (High Complexity)': 'prodHigh',
    'SDTM Production and Validation: Programs and Datasets (Medium Complexity)': 'prodMedium',
    'SDTM Pinnacle 21 Report Creation and Review': 'pinnacle21',
    "SDTM Reviewer's Guide": 'reviewersGuide',
    'SDTM Define.xml': 'defineXml',
    'SDTM Dataset File xpt Conversion and Review': 'xptConversion',

    // ADaM family
    'ADaM Dataset Specs (High Complexity)': 'adam_specs_high',
    'ADaM Dataset Specs (Medium Complexity)': 'adam_specs_medium',
    'ADaM Production and Validation: Programs and Datasets (High Complexity)': 'adam_prod_high',
    'ADaM Production and Validation: Programs and Datasets (Medium Complexity)': 'adam_prod_medium',
    'ADaM Pinnacle 21 Report Creation and Review': 'adam_pinnacle21',
    'ADaM Review\'s Guide': 'adam_reviewersGuide',
    'ADaM Define.xml': 'adam_defineXml',
    'ADaM Dataset Program xpt Conversion and Review': 'adam_xptConversion',
    'ADaM Program txt Conversion and Review': 'adam_txtConversion',

    // Other analysis tasks
    'Statistical Analysis Plan Draft 1': 'sap_draft1',
    'Statistical Analysis Plan Draft 2': 'sap_draft2',
    'Statistical Analysis Plan Final': 'sap_final',
    'Analysis Shells Development': 'analysis_shells',
    'Mock Tables, Listings, and Figures': 'mock_tlfs',

    // Generic fallbacks (legacy)
    'Statistical Analysis Plan (SAP)': 'sap',
    'Tables, Listings, and Figures (TLFs)': 'tlfs',
    'Interim Analysis': 'interim_analysis',
    'Final Analysis': 'final_analysis',
    'CDISC Data Transfer to Sponsor': 'data_transfer'
  };
  
  return taskMapping[taskName] || null;
}

// 🔄 Excel状态管理函数
async function cacheExcelState(stepNumber) {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      const usedRange = worksheet.getUsedRange();
      
      if (usedRange) {
        usedRange.load(['values', 'formulas', 'format/fill/color', 'format/font', 'format/borders', 'format/numberFormat']);
        await context.sync();
        
        // 缓存Excel内容和格式
        excelStateCache[`step${stepNumber}`] = {
          values: usedRange.values,
          formulas: usedRange.formulas,
          rowCount: usedRange.rowCount,
          columnCount: usedRange.columnCount,
          cached: true,
          timestamp: new Date().toISOString()
        };
        
        console.log(`✅ Excel状态已缓存到 step${stepNumber}:`, excelStateCache[`step${stepNumber}`]);
      } else {
        // 空白状态
        excelStateCache[`step${stepNumber}`] = {
          isEmpty: true,
          cached: true,
          timestamp: new Date().toISOString()
        };
        console.log(`✅ 空白Excel状态已缓存到 step${stepNumber}`);
      }
    });
  } catch (error) {
    console.error(`❌ 缓存Excel状态失败 (step${stepNumber}):`, error);
  }
}

async function restoreExcelState(stepNumber) {
  try {
    const cachedState = excelStateCache[`step${stepNumber}`];
    if (!cachedState || !cachedState.cached) {
      console.log(`⚠️ 没有找到 step${stepNumber} 的缓存状态`);
      return;
    }
    
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // 先清空当前内容
      const usedRange = worksheet.getUsedRange();
      if (usedRange) {
        usedRange.clear();
        await context.sync();
      }
      
      if (cachedState.isEmpty) {
        // 恢复空白状态
        console.log(`✅ 已恢复空白Excel状态 (step${stepNumber})`);
        return;
      }
      
      // 恢复缓存的内容
      if (cachedState.values && cachedState.values.length > 0) {
        const range = worksheet.getRangeByIndexes(0, 0, cachedState.rowCount, cachedState.columnCount);
        
        // 恢复数值和公式
        if (cachedState.formulas) {
          range.formulas = cachedState.formulas;
        } else {
          range.values = cachedState.values;
        }
        
        await context.sync();
        console.log(`✅ 已恢复Excel状态到 step${stepNumber}`);
      }
    });
    
    showStatusMessage(`Excel content restored to Step ${stepNumber} state.`, 'success');
  } catch (error) {
    console.error(`❌ 恢复Excel状态失败 (step${stepNumber}):`, error);
    showStatusMessage(`Failed to restore Excel state: ${error.message}`, 'error');
  }
}

// Wizard state
let currentWizardStep = 1; // 1: Welcome, 2: Resume, 3: Project, 4: Upload, 5: SDTM

function initWizard() {
  const backBtn = document.getElementById('wizard-back-btn');
  const nextBtn = document.getElementById('wizard-next-btn');
  backBtn.addEventListener('click', async () => {
    // 智能Back导航：跳过被删除的Step 2，同时恢复Excel状态
    let targetStep = null;
    
    if (currentWizardStep === 2) {
      targetStep = 1;  // Upload → AI
    } else if (currentWizardStep === 3) {
      targetStep = 2;  // Project Selection → Upload
    } else if (currentWizardStep === 4) {
      targetStep = 3;  // Analysis Progress → Project Selection（进度页返回上一步）
    } else if (currentWizardStep === 5) {
      targetStep = 4;  // Results → Analysis Progress（保持一致性）
    } else if (currentWizardStep === 6) {
      targetStep = 5;  // Completion → Results
    } else if (currentWizardStep > 1) {
      targetStep = currentWizardStep - 1;
    }
    
    if (targetStep) {
      // 先恢复Excel状态，再切换页面
      await restoreExcelState(targetStep);
      showStep(targetStep);
    }
  });
  nextBtn.addEventListener('click', async () => { await handleNext(); });
  
  // 初始化聊天界面
  initChatInterface();
  
  showStep(1);
}

// 初始化聊天界面
function initChatInterface() {
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  
  if (chatInput && chatSendBtn) {
    // 发送按钮点击事件
    chatSendBtn.addEventListener('click', handleChatSend);
    
    // 输入框回车事件
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleChatSend();
      }
    });
    
    // 输入框焦点事件
    chatInput.addEventListener('input', () => {
      const sendBtn = document.getElementById('chat-send-btn');
      const hasText = chatInput.value.trim().length > 0;
      sendBtn.disabled = !hasText;
    });
  }
}

// 🔥 重置AI聊天界面到初始状态
function resetAIChatInterface() {
  const chatMessages = document.getElementById('chat-messages');
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  
  if (chatMessages) {
    // 清空所有聊天消息
    chatMessages.innerHTML = '';
    
    // 重新添加初始欢迎消息
    const initialMessage = document.createElement('div');
    initialMessage.className = 'message ai-message';
    initialMessage.innerHTML = `
      <div class="message-content">
        Hello! What would you like to do today? 
        <br><br>You can say something like:
        <br>• "I want to do Phase II study cost analysis for study SK123-kbi"
        <br>• "Help me estimate costs for an oncology trial (study number: ABC-123)"
        <br>• "I need SDTM mapping for study SK123-kbi protocol"
      </div>
    `;
    chatMessages.appendChild(initialMessage);
  }
  
  // 清空输入框
  if (chatInput) {
    chatInput.value = '';
  }
  
  // 重置发送按钮状态
  if (chatSendBtn) {
    chatSendBtn.disabled = true;
  }
  
  // 重置相关状态变量
  lastParsedCommand = null;
  
  console.log('✅ AI聊天界面已重置到初始状态');
}

// 最近一次解析结果
let lastParsedCommand = null;

// 处理聊天发送（调用后端解析 → 确认 → 查库 → 导航）
async function handleChatSend() {
  const chatInput = document.getElementById('chat-input');
  const userMessage = chatInput.value.trim();
  if (!userMessage) return;

  addChatMessage(userMessage, 'user');
  chatInput.value = '';
  document.getElementById('chat-send-btn').disabled = true;

  // 检查是否在等待确认状态
  if (window.pendingConfirmation) {
    await handleConfirmationResponse(userMessage);
    return;
  }

  showTypingIndicator();
  try {
    const parsed = await callAssistantParseCommand(userMessage);
    hideTypingIndicator();

    if (!parsed || (!parsed.studyIdentifier && !parsed.matchedTask)) {
      // 检查是否是通用的"开始新项目"请求
      if (userMessage.toLowerCase().includes('start') || userMessage.toLowerCase().includes('new project') || userMessage.toLowerCase().includes('upload')) {
        addChatMessage("Let me take you to start a new project by uploading your protocol.", 'ai');
        await delayedNavigation(3);
        return;
      }
      addChatMessage("I couldn't understand the study number or task. Supported tasks are: Cost Estimate, SAS Analysis. Please try e.g. 'I want to do Cost Estimate for study SK123-KBI', or say 'start new project'.", 'ai');
      return;
    }

    lastParsedCommand = parsed;
    const studyText = parsed.studyIdentifier ? parsed.studyIdentifier : '(study number not provided)';
    const taskText = parsed.matchedTask ? parsed.matchedTask.name : '(task not recognized)';
    askForConfirmation(studyText, taskText, parsed.matchedTask ? parsed.matchedTask.key : null);
      } catch (e) {
      hideTypingIndicator();
      addChatMessage('Sorry, parsing failed. Please try again, or say "start new project" to proceed with upload.', 'ai');
    }
}

async function callAssistantParseCommand(text) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/parse-command`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text })
  });
  if (!resp.ok) throw new Error('parse failed');
  const data = await resp.json();
  return data?.data || null;
}

function askForConfirmation(studyIdentifier, taskName, taskKey) {
  const msg = `Did you mean you want ${taskName} for study ${studyIdentifier}?`;
  addChatMessage(msg, 'ai');
  
  // 设置等待确认状态
  window.pendingConfirmation = {
    studyIdentifier,
    taskName,
    taskKey
  };
}

async function handleConfirmationResponse(userMessage) {
  showTypingIndicator();
  
  try {
    // 调用AI解析用户的Yes/No意向
    const intent = await parseYesNoIntent(userMessage);
    hideTypingIndicator();
    
    if (intent === 'yes') {
      const { studyIdentifier, taskKey } = window.pendingConfirmation;
      if (!taskKey) {
        addChatMessage('Task not recognized. Supported tasks: Cost Estimate, SAS Analysis. Please rephrase your request.', 'ai');
        window.pendingConfirmation = null;
        return;
      }
      
      showTypingIndicator();
      try {
        const lookup = await callAssistantLookupStudyTask(studyIdentifier, taskKey);
        hideTypingIndicator();
        window.pendingConfirmation = null;
        await handleLookupResult(lookup);
      } catch (err) {
        hideTypingIndicator();
        addChatMessage('Lookup failed. Let me take you to start a new project.', 'ai');
        window.pendingConfirmation = null;
        await delayedNavigation(3);
      }
    } else if (intent === 'no') {
      window.pendingConfirmation = null;
      addChatMessage("Please tell me again what you want to do. For example: 'I want to do Cost Estimate for study SK123-KBI'.", 'ai');
    } else {
      addChatMessage("I couldn't understand if you meant yes or no. Please respond with something like 'yes', 'no', 'correct', or 'not correct'.", 'ai');
    }
  } catch (e) {
    hideTypingIndicator();
    addChatMessage("Sorry, I couldn't process your response. Please say 'yes' or 'no'.", 'ai');
  } finally {
    document.getElementById('chat-send-btn').disabled = false;
  }
}

async function parseYesNoIntent(text) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/parse-command`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      text: `Parse this as yes/no intent: "${text}". Return only "yes", "no", or "unclear".`,
      type: 'yesno_intent'
    })
  });
  
  if (!resp.ok) throw new Error('Intent parsing failed');
  const data = await resp.json();
  
  // 简单的客户端解析作为备选
  const lowerText = text.toLowerCase().trim();
  
  // 各种Yes的表达方式
  const yesPatterns = [
    'yes', 'y', 'yeah', 'yep', 'correct', 'right', 'true', 'ok', 'okay', 
    'sure', 'exactly', 'that\'s right', 'confirm', 'confirmed', 'agreed'
  ];
  
  // 各种No的表达方式  
  const noPatterns = [
    'no', 'n', 'nope', 'wrong', 'incorrect', 'false', 'not right', 
    'not correct', 'that\'s wrong', 'cancel', 'redo'
  ];
  
  if (yesPatterns.some(pattern => lowerText.includes(pattern))) {
    return 'yes';
  } else if (noPatterns.some(pattern => lowerText.includes(pattern))) {
    return 'no';
  }
  
  return 'unclear';
}

async function callAssistantLookupStudyTask(studyIdentifier, taskKey) {
  const resp = await fetch(`${API_BASE_URL}/api/v2/lookup-study-task`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ studyIdentifier, taskKey })
  });
  if (!resp.ok) throw new Error('lookup failed');
  const data = await resp.json();
  return data?.data || null;
}

async function handleLookupResult(data) {
  if (!data || data.foundStudy === false) {
    addChatMessage("We could not find any records for this study. Let me take you to start a new one.", 'ai');
    await delayedNavigation(2); // 跳转到Upload页面 (Step 2)，而不是Project Selection (Step 3)
    return;
  }

  // foundStudy === true
  if (data.isUnfinished === true && data.documentId) {
    addChatMessage(`I found an unfinished '${data.taskName}' for study '${data.studyNumber}'. Loading it now...`, 'ai');
    window.currentDocumentId = data.documentId;
    await saveDocumentIdToSettings(data.documentId);
    await delayedNavigationWithCallback(5, async () => {
      await restoreApplicationState(data.documentId);
    });
    return;
  }

  if (data.isUnfinished === false) {
    // 项目已完成的情况
    addChatMessage(`I found that '${data.taskName}' for study '${data.studyNumber}' is already completed. Let me take you to start a new one.`, 'ai');
  } else {
    // 状态不明确的情况
    addChatMessage("We could not check unfinished project for this study. Let me take you to start a new one.", 'ai');
  }
  await delayedNavigation(2); // 跳转到Upload页面，而不是Project Selection
}

// 延迟跳转功能（带视觉提示）
async function delayedNavigation(targetStep, delayMs = 2000) {
  // 等待AI消息显示完整
  await new Promise(resolve => setTimeout(resolve, delayMs));
  
  // 显示准备跳转的提示
  const countdownDiv = document.createElement('div');
  countdownDiv.className = 'message ai-message';
  countdownDiv.innerHTML = `<div class="message-content" style="font-style: italic; color: #666; border: 1px solid #e0e0e0; background-color: #f8f9fa; padding: 8px; border-radius: 6px;">Preparing to redirect...</div>`;
  
  const chatMessages = document.getElementById('chat-messages');
  chatMessages.appendChild(countdownDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // 等待1秒后跳转
  await new Promise(resolve => setTimeout(resolve, 1000));
  countdownDiv.remove();
  showStep(targetStep);
}

// 延迟跳转功能（带回调函数）
async function delayedNavigationWithCallback(targetStep, callback, delayMs = 2000) {
  // 等待AI消息显示完整
  await new Promise(resolve => setTimeout(resolve, delayMs));
  
  // 显示准备加载的提示
  const countdownDiv = document.createElement('div');
  countdownDiv.className = 'message ai-message';
  countdownDiv.innerHTML = `<div class="message-content" style="font-style: italic; color: #666; border: 1px solid #e0e0e0; background-color: #f8f9fa; padding: 8px; border-radius: 6px;">Loading previous work...</div>`;
  
  const chatMessages = document.getElementById('chat-messages');
  chatMessages.appendChild(countdownDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // 等待1秒后执行回调和跳转
  await new Promise(resolve => setTimeout(resolve, 1000));
  countdownDiv.remove();
  
  if (callback) await callback();
  showStep(targetStep);
}

// 添加聊天消息
function addChatMessage(message, sender) {
  const chatMessages = document.getElementById('chat-messages');
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${sender}-message`;
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'message-content';
  
  contentDiv.textContent = message;
  
  messageDiv.appendChild(contentDiv);
  chatMessages.appendChild(messageDiv);
  
  // 滚动到底部
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// 显示打字指示器
function showTypingIndicator() {
  const chatMessages = document.getElementById('chat-messages');
  const typingDiv = document.createElement('div');
  typingDiv.className = 'message ai-message typing-indicator';
  typingDiv.id = 'typing-indicator';
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'message-content';
  contentDiv.innerHTML = '<strong>LLX AI:</strong> <span class="typing-dots">Thinking<span>.</span><span>.</span><span>.</span></span>';
  
  typingDiv.appendChild(contentDiv);
  chatMessages.appendChild(typingDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// 隐藏打字指示器
function hideTypingIndicator() {
  const typingIndicator = document.getElementById('typing-indicator');
  if (typingIndicator) {
    typingIndicator.remove();
  }
}

// 生成AI回复
function generateAIResponse(userMessage) {
  const lowerMessage = userMessage.toLowerCase();
  
  // 匹配研究类型关键词
  if (lowerMessage.includes('phase') || lowerMessage.includes('study') || lowerMessage.includes('trial')) {
    if (lowerMessage.includes('phase i') || lowerMessage.includes('phase 1')) {
      return "Great! I understand you're working on a Phase I study. Phase I trials typically focus on safety and dosing. I'll help you set up a cost analysis that includes SDTM mapping, safety monitoring, and PK assessments. Click 'Next' to begin the protocol upload.";
    } else if (lowerMessage.includes('phase ii') || lowerMessage.includes('phase 2')) {
      return "Excellent! Phase II studies focus on efficacy while continuing safety monitoring. I'll guide you through setting up cost estimates for SDTM datasets, efficacy endpoints, and interim analyses. Click 'Next' to start with your protocol.";
    } else if (lowerMessage.includes('phase iii') || lowerMessage.includes('phase 3')) {
      return "Perfect! Phase III trials are large confirmatory studies. I'll help you plan for extensive SDTM/ADaM datasets, multiple interim analyses, and comprehensive safety reporting. Let's begin with uploading your protocol - click 'Next'.";
    }
  }
  
  // 匹配治疗领域
  if (lowerMessage.includes('oncology') || lowerMessage.includes('cancer')) {
    return "Oncology trials have specific requirements including tumor assessments, survival endpoints, and specialized SDTM domains like TU (Tumor Identification) and RS (Disease Response). I'll help you set up the appropriate cost structure. Click 'Next' to upload your protocol.";
  }
  
  // 匹配SDTM相关
  if (lowerMessage.includes('sdtm') || lowerMessage.includes('mapping')) {
    return "SDTM mapping is crucial for regulatory submissions! I'll analyze your protocol's Schedule of Assessments and automatically map procedures to appropriate SDTM domains, then estimate the complexity and costs. Ready to start? Click 'Next' to upload your protocol.";
  }
  
  // 匹配成本分析
  if (lowerMessage.includes('cost') || lowerMessage.includes('estimate') || lowerMessage.includes('budget')) {
    return "I'll help you create a comprehensive cost analysis including SDTM/ADaM production, statistical analysis plans, interim analyses, and data transfers. The system will automatically calculate costs based on your protocol complexity. Let's get started - click 'Next'!";
  }
  
  // 通用回复
  return "I understand you want to work on a clinical study project. I can help you with cost estimation, SDTM mapping, and data management planning. To get started, please click 'Next' to upload your protocol document, and I'll guide you through the entire process step by step.";
}

function showStep(step) {
  currentWizardStep = step;
  const pages = document.querySelectorAll('.wizard-page');
  pages.forEach(p => {
    const s = Number(p.getAttribute('data-step'));
    p.style.display = (s === step) ? 'block' : 'none';
  });
  
  const backBtn = document.getElementById('wizard-back-btn');
  const nextBtn = document.getElementById('wizard-next-btn');
  const navContainer = document.querySelector('.wizard-nav');
  
  if (step === 1) {
    // Step 1 (AI Assistant): 隐藏所有导航按钮，强制通过聊天交互
    if (navContainer) navContainer.style.display = 'none';
  } else {
    // 其他步骤：显示导航按钮
    if (navContainer) navContainer.style.display = 'flex';
    backBtn.disabled = (step === 1);  // 只有Step 1禁用Back按钮
    nextBtn.disabled = false;
    nextBtn.querySelector('.ms-Button-label').textContent = (step === 6) ? 'Done' : 'Next';
  }
}



async function handleNext() {
  if (currentWizardStep === 1) {
    // Step1 → Step2 (Upload)
    await cacheExcelState(1);
    showStep(2);
    return;
  }
  if (currentWizardStep === 2) {
    // Step2 (Upload) → Step3 (Project Selection)
    await cacheExcelState(2);
    if (!window.currentDocumentId) {
      showStatusMessage('Please upload a protocol document before proceeding.', 'error');
      return;
    }
    showStep(3);
    return;
  }
  if (currentWizardStep === 3) {
    // Step3 (Project Selection) → Step4 (Analysis Progress) → 后台触发分析
    await cacheExcelState(3);
    if (window.currentDocumentId) {
      try { await saveProjectSelectionDetails(); } catch (e) { console.warn('保存项目选择失败但不阻塞进入下一步:', e); }
    }
    await createStandardCostAnalysisHeaders();
    await populateExcelWithSelectedProjects();

    // 启动分析（显示分析进度页），完成后进入结果页
    if (!window.currentDocumentId) {
      showStatusMessage('Missing document id. Please upload again.', 'error');
      return;
    }
    showStep(4);
    try {
      const resp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/analyze-sdtm`, { method: 'POST' });
      const result = await resp.json();
      if (result?.success) {
        showStatusMessage('SDTM analysis completed.', 'success');
      } else {
        showStatusMessage('SDTM analysis failed or incomplete. You can review later.', 'error');
      }
    } catch (e) {
      console.warn('分析触发失败:', e);
      showStatusMessage('Failed to start analysis. You can review later.', 'error');
    }

    // 拉取最新文档内容并显示（若有）
    try {
      const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
      if (response.ok) {
        const docData = await response.json();
        const sdtmData = docData?.document?.sdtmData;
        if (sdtmData) {
          const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
            (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
            (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
          ));
          const source = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          if (source && source.procedures) {
            displaySDTMAnalysis(source);
          }
        }
      }
    } catch (e) { console.warn('进入SDTM结果页前获取SDTM失败:', e); }

    // Analysis完成 → 进入结果页（Step5）
    showStep(5);
    return;
  }
  if (currentWizardStep === 4) {
    // Step4 (Analysis Progress) → Step5 (Results) 
    // 如果用户在分析进度页面点击Next，直接跳转到结果页
    await cacheExcelState(4);
    showStep(5);
    return;
  }
  if (currentWizardStep === 5) {
    // Step5 (Results) → Step6 (Completion)
    await cacheExcelState(5);
    showStep(6);
    return;
  }
  if (currentWizardStep === 6) {
    // Step6 Done：标记数据库 isCostEstimate = true，保存Excel，清空，回到开始
    await cacheExcelState(6);
    if (!window.currentDocumentId) {
      showStatusMessage('Missing document id. Please upload again.', 'error');
      return;
    }
    try {
      const resp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/mark-complete`, { method: 'PATCH' });
      const result = await resp.json();
      if (result?.success) {
        showStatusMessage('Project completed! Saving Excel file and starting fresh...', 'success');
        
        // 保存Excel到本地
        await saveExcelToLocal();
        
        // 清空Excel内容
        await clearExcelContent();
        
        // 重置状态并回到开始页
        await resetToStart();
        
      } else {
        showStatusMessage('Failed to mark as completed: ' + (result?.message || ''), 'error');
      }
    } catch (err) {
      showStatusMessage('Failed to mark as completed: ' + err.message, 'error');
    }
  }
}

// 初始化时调用
(function attachWizardInit(){
  const origOnReady = Office.onReady;
  // 在 Office.onReady 的回调中调用 initWizard（文件上方已有 Office.onReady，我们直接在其内部也调用即可）
})();

async function checkAndOfferResume() {
  try {
    // 1) 若已绑定 documentId，优先直接恢复
    const savedDocumentId = await loadDocumentIdFromSettings();
    if (savedDocumentId) {
      await restoreApplicationState(savedDocumentId);
      return; // 已绑定则无需弹窗
    }

    // 2) 拉取未完成列表
    const resp = await fetch(`${API_BASE_URL}/api/documents/incomplete-estimates`);
    const data = await resp.json();
    const list = Array.isArray(data?.data) ? data.data : [];

    // 3) 准备弹窗元素
    const modal = document.getElementById('start-modal');
    const listEl = document.getElementById('incomplete-list');
    const btnNew = document.getElementById('start-new-btn');
    const btnContinue = document.getElementById('continue-selected-btn');
    const titleEl = document.getElementById('start-modal-title');
    const descEl = document.getElementById('start-modal-desc');

    let selectedId = null;

    // 4) 根据是否有未完成项调整文案与按钮
    if (list.length > 0) {
      titleEl.textContent = 'Welcome back';
      descEl.textContent = 'We found unfinished studies. Continue or start a new estimate?';
      btnContinue.style.display = '';
      btnContinue.setAttribute('disabled', 'true');
      listEl.classList.add('has-items');
      listEl.innerHTML = '';
      list.forEach(doc => {
        const div = document.createElement('div');
        div.className = 'item';
        const title = (doc.studyNumber && doc.studyNumber !== 'N/A') ? doc.studyNumber : '(No Study Number)';
        const subtitle = doc.originalName || '';
        const uploaded = doc.uploadedAt ? new Date(doc.uploadedAt).toLocaleString() : '';
        div.innerHTML = `
          <div class="check"></div>
          <div class="info">
            <div class="title">${title}</div>
            <div class="subtitle">${subtitle}</div>
            <div class="meta">Uploaded: ${uploaded}</div>
          </div>
        `;
        div.addEventListener('click', () => {
          Array.from(listEl.children).forEach(c => c.classList.remove('selected'));
          div.classList.add('selected');
          selectedId = doc._id;
          btnContinue.removeAttribute('disabled');
        });
        listEl.appendChild(div);
      });
    } else {
      titleEl.textContent = 'Start a New Cost Estimate?';
      descEl.textContent = 'No unfinished studies found. Would you like to start a new one?';
      btnContinue.style.display = 'none';
      listEl.classList.remove('has-items');
      listEl.innerHTML = '';
    }

    // 5) 显示弹窗并绑定按钮
    modal.style.display = 'flex';

    btnNew.onclick = () => {
      modal.style.display = 'none';
      showStep(1); // 新开
    };
    btnContinue.onclick = async () => {
      if (!selectedId) { showStatusMessage('Please select a study to continue.', 'error'); return; }
      modal.style.display = 'none';
      await saveDocumentIdToSettings(selectedId);
      await restoreApplicationState(selectedId);
      showStep(3);
    };
  } catch (err) {
    console.warn('启动时检查未完成列表失败:', err);
    // 兜底：失败时也给用户开始新建的选择
    try {
      const modal = document.getElementById('start-modal');
      const listEl = document.getElementById('incomplete-list');
      const btnNew = document.getElementById('start-new-btn');
      const btnContinue = document.getElementById('continue-selected-btn');
      const titleEl = document.getElementById('start-modal-title');
      const descEl = document.getElementById('start-modal-desc');
      titleEl.textContent = 'Start a New Cost Estimate?';
      descEl.textContent = 'We could not check unfinished studies. You can still start a new one.';
      btnContinue.style.display = 'none';
      listEl.classList.remove('has-items');
      listEl.innerHTML = '';
      modal.style.display = 'flex';
      btnNew.onclick = () => { modal.style.display = 'none'; showStep(1); };
    } catch (_) {}
  }
}

// 在 Office.onReady 中，初始化后调用
Office.onReady(async (info) => {
  if (info.host === Office.HostType.Excel) {
    document.getElementById("sideload-msg").style.display = "none";
    document.getElementById("app-body").style.display = "flex";
    
    initWizard();
    initFileUpload();
    initExcelChangeTracking(); // 初始化Excel变化监听

    // 兜底恢复：若文件设置已有documentId，在欢迎页直接恢复并跳转第5步
    try {
      const savedDocumentId = await loadDocumentIdFromSettings();
      if (savedDocumentId) {
        await restoreApplicationState(savedDocumentId);
        showStep(5); // 结果页（新编号）
      } else {
        showStep(1);
      }
    } catch (error) {
      console.error('❌ 启动时恢复状态失败:', error);
      showStep(1);
    }
  }
});

// 初始化文件上传功能
function initFileUpload() {
  // Protocol upload
  const protocolSelectBtn = document.getElementById('protocol-select-btn');
  const protocolFileInput = document.getElementById('protocol-file-input');
  const protocolUploadArea = document.getElementById('protocol-upload-area');
  const protocolCancelBtn = document.getElementById('protocol-cancel-btn');
  const protocolRemoveBtn = document.getElementById('protocol-remove-btn');



  // Protocol upload events
  protocolSelectBtn.addEventListener('click', () => protocolFileInput.click());
  protocolUploadArea.addEventListener('click', () => protocolFileInput.click());
  protocolFileInput.addEventListener('change', (e) => handleProtocolUpload(e.target.files[0]));
  protocolCancelBtn.addEventListener('click', cancelProtocolUpload);
  protocolRemoveBtn.addEventListener('click', removeProtocolFile);

  // Drag and drop for protocol
  protocolUploadArea.addEventListener('dragover', handleDragOver);
  protocolUploadArea.addEventListener('drop', (e) => handleProtocolDrop(e));
  protocolUploadArea.addEventListener('dragenter', handleDragEnter);
  protocolUploadArea.addEventListener('dragleave', handleDragLeave);

  // 🔥 新增：项目选择动态输入框逻辑
  initProjectSelectionLogic();
  


}

// 拖拽处理函数
function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';
}

function handleDragEnter(e) {
  e.preventDefault();
  e.currentTarget.classList.add('dragover');
}

function handleDragLeave(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('dragover');
}

function handleProtocolDrop(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('dragover');
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    handleProtocolUpload(files[0]);
  }
}



// Protocol文件上传处理（仅存储，不触发分析，也不立即填充Excel）
async function handleProtocolUpload(file) {
  if (!file) return;

  const allowedTypes = [ 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ];
  if (!allowedTypes.includes(file.type)) {
    showStatusMessage('Please select PDF or Word documents only', 'error');
    return;
  }

  showProtocolProgress();
  try {
    const formData = new FormData();
    formData.append('document', file);
    formData.append('documentType', 'ClinicalProtocol');

    const response = await fetch(`${API_BASE_URL}/api/upload-document`, { method: 'POST', body: formData });
    if (!response.ok) { throw new Error(`Upload failed: ${response.statusText}`); }
    const result = await response.json();

    uploadedProtocol = { name: file.name, size: file.size, type: file.type, uploadId: result.uploadId };

    if (result.uploadId) {
      window.currentDocumentId = result.uploadId;
      await saveDocumentIdToSettings(result.uploadId);
    }

    showProtocolResult(file);
    showStatusMessage('Clinical Protocol uploaded. Click Next to select projects.', 'success');
  } catch (error) {
    console.error('Protocol upload error:', error);
    showStatusMessage(`Upload failed: ${error.message}`, 'error');
    hideProtocolProgress();
  }
}



// UI更新函数
function showProtocolProgress() {
  document.getElementById('protocol-upload-area').style.display = 'none';
  document.getElementById('protocol-progress').style.display = 'block';
  document.getElementById('protocol-result').style.display = 'none';
}

function hideProtocolProgress() {
  document.getElementById('protocol-upload-area').style.display = 'block';
  document.getElementById('protocol-progress').style.display = 'none';
}

function showProtocolResult(file) {
  document.getElementById('protocol-upload-area').style.display = 'none';
  document.getElementById('protocol-progress').style.display = 'none';
  document.getElementById('protocol-result').style.display = 'block';
  
  document.getElementById('protocol-file-name').textContent = file.name;
  document.getElementById('protocol-file-status').textContent = '✅ Clinical Protocol uploaded to MongoDB';
}

function cancelProtocolUpload() {
  hideProtocolProgress();
  showStatusMessage('Protocol upload cancelled', 'info');
  }

async function removeProtocolFile() {
  uploadedProtocol = null;
  window.currentDocumentId = null;
  currentSDTMData = null;
  
  document.getElementById('protocol-upload-area').style.display = 'block';
  document.getElementById('protocol-result').style.display = 'none';
  document.getElementById('protocol-file-input').value = '';
  
  // 隐藏SDTM分析结果
  hideSDTMAnalysis();
  
  // 🔥 新增：清除Excel设置中的持久化存储
  await clearDocumentIdFromSettings();
  
  // 重置项目选择状态
  const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
  checkboxes.forEach(checkbox => {
    checkbox.checked = false;
    const dataAttr = checkbox.getAttribute('data-requires-count');
    if (dataAttr) {
      const container = document.getElementById(`${dataAttr}-container`);
      const input = document.getElementById(`${dataAttr}-count`);
      if (container) container.style.display = 'none';
      if (input) input.value = '';
    }
  });
  
  showStatusMessage('Clinical Protocol removed', 'info');
}





// 工具函数
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function showStatusMessage(message, type) {
  const statusElement = document.getElementById('status-message');
  statusElement.textContent = message;
  statusElement.className = `status-message ${type}`;
  
  if (type === 'success' || type === 'info') {
    setTimeout(() => {
  statusElement.className = 'status-message';
    }, 3000);
  }
}

// 📁 持久化存储函数 - 用于在Excel文件中保存/恢复文档ID
async function saveDocumentIdToSettings(documentId) {
  try {
    await Excel.run(async (context) => {
      const settings = context.workbook.settings;
      
      // 尝试删除现有设置（如果存在）
      try {
        settings.getItem("currentDocumentId").delete();
      } catch (e) {
        // 设置不存在，忽略错误
      }
      
      // 添加新的设置
      settings.add("currentDocumentId", documentId);
      await context.sync();
      console.log('✅ 文档ID已保存到Excel设置:', documentId);
    });
  } catch (error) {
    console.error('❌ 保存文档ID失败:', error);
  }
}

async function loadDocumentIdFromSettings() {
  try {
    return await Excel.run(async (context) => {
      const settings = context.workbook.settings;
      const documentIdSetting = settings.getItem("currentDocumentId");
      context.load(documentIdSetting, "value");
      await context.sync();
      
      if (documentIdSetting.value) {
        console.log('✅ 从Excel设置中恢复文档ID:', documentIdSetting.value);
        return documentIdSetting.value;
      }
      return null;
    });
  } catch (error) {
    console.error('❌ 读取文档ID失败:', error);
    return null;
  }
}

async function clearDocumentIdFromSettings() {
  try {
    await Excel.run(async (context) => {
      context.workbook.settings.getItem("currentDocumentId").delete();
      await context.sync();
      console.log('✅ 已清除Excel设置中的文档ID');
    });
  } catch (error) {
    console.error('❌ 清除文档ID失败:', error);
  }
}

// 🔄 状态恢复函数 - 根据文档ID恢复所有界面状态
async function restoreApplicationState(documentId) {
  try {
    window.currentDocumentId = documentId;
    showStatusMessage('Restoring data state...', 'info');
    
    // 1. 获取文档数据
    const response = await fetch(`${API_BASE_URL}/api/documents/${documentId}/content`);
    if (!response.ok) {
      throw new Error('Failed to fetch document data');
    }
    
    const docData = await response.json();
    if (!docData.success) {
      throw new Error(docData.message || 'Failed to get document content');
    }
    
    const document = docData.document;
    
    // 2. 恢复SDTM数据显示
    if (document.sdtmData && (document.sdtmData.confirmed || document.sdtmData.original)) {
      const sdtmData = document.sdtmData.confirmed || document.sdtmData.original;
      if (sdtmData && sdtmData.procedures) {
        currentSDTMData = {
          success: true, // 确保 success 为 true
          procedures: sdtmData.procedures,
          mappings: sdtmData.mappings || [],
          summary: sdtmData.summary || {}
        };
        
        // 显示SDTM分析结果
        displaySDTMAnalysis(currentSDTMData);
        showStatusMessage('SDTM analysis data restored', 'success');
      }
    }
    
    // 3. 恢复项目选择状态
    if (document.projectSelectionDetails) {
      restoreProjectSelections(document.projectSelectionDetails);
    }
    
    // 4. 重新填充Excel表格
    await createStandardCostAnalysisHeaders();
    await populateExcelWithSelectedProjects();
    
    // 4.1 恢复已保存的 Units/Costs（优先使用用户在Excel中修改过的units，其次使用SDTM确认时的初始快照）
    try {
      const costEstimate = document?.costEstimate || {};
      if (costEstimate && typeof costEstimate === 'object') {
        if (costEstimate.units && Object.keys(costEstimate.units).length > 0) {
          console.log('🔄 恢复用户最近在Excel修改过的 Units 到表格:', costEstimate.units);
          await applyUnitsToExcel(costEstimate.units);
        } else if (costEstimate['SDTM Datasets Production and Validation']) {
          console.log('🔄 使用SDTM确认时的快照恢复 Units/Costs');
          await applySDTMUnitsAndCostsToExcel(costEstimate['SDTM Datasets Production and Validation']);
        }
      }
    } catch (e) {
      console.warn('恢复Units/Costs到Excel时出现问题:', e);
    }
    
    showStatusMessage('All data restored successfully!', 'success');
    
  } catch (error) {
    console.error('❌ 恢复应用状态失败:', error);
    showStatusMessage('Failed to restore data: ' + error.message, 'error');
  }
}

// 🎯 恢复项目选择状态
function restoreProjectSelections(projectSelectionDetails) {
  try {
    // 清除所有现有的选择
    const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      checkbox.checked = false;
      // 隐藏相关的计数输入框
      const dataAttr = checkbox.getAttribute('data-requires-count');
      if (dataAttr) {
        const container = document.getElementById(`${dataAttr}-container`);
        if (container) {
          container.style.display = 'none';
        }
      }
    });
    
    // 根据保存的数据恢复选择状态
    Object.entries(projectSelectionDetails).forEach(([projectName, count]) => {
      if (projectName === 'lastUpdated') return;
      
      // 查找对应的checkbox
      const checkbox = Array.from(checkboxes).find(cb => {
        const label = cb.nextElementSibling;
        if (label && label.classList.contains('ms-CheckBox-label')) {
          const textSpan = label.querySelector('.ms-CheckBox-text');
          return textSpan && textSpan.textContent.trim() === projectName;
        }
        return false;
      });
      
      if (checkbox) {
        checkbox.checked = true;
        
        // 如果有计数信息，显示输入框并填充数值
        const dataAttr = checkbox.getAttribute('data-requires-count');
        if (dataAttr && count && count > 0) {
          const container = document.getElementById(`${dataAttr}-container`);
          const input = document.getElementById(`${dataAttr}-count`);
          if (container && input) {
            container.style.display = 'flex';
            input.value = count;
          }
        }
      }
    });
    
    console.log('✅ 项目选择状态已恢复');
  } catch (error) {
    console.error('❌ 恢复项目选择状态失败:', error);
  }
}

// 全局变量来存储当前的SDTM数据和状态
let currentSDTMData = null;
let isEditMode = false;
let selectedProcedureIndex = 0;

// SDTM分析结果显示函数
function displaySDTMAnalysis(sdtmAnalysis) {
  console.log('显示SDTM分析结果:', sdtmAnalysis);
  
  // 存储当前数据，并确保 success 有合理的默认
  const inferredSuccess = (sdtmAnalysis && (
    sdtmAnalysis.success === true ||
    (sdtmAnalysis.success === undefined && Array.isArray(sdtmAnalysis.procedures) && sdtmAnalysis.procedures.length > 0)
  ));

  currentSDTMData = {
    success: inferredSuccess === true,
    procedures: [...(sdtmAnalysis.procedures || [])],
    mappings: [...(sdtmAnalysis.mappings || [])],
    summary: { ...(sdtmAnalysis.summary || {}) }
  };
  
  const sdtmSection = document.getElementById('sdtm-analysis-section');
  const sdtmStatus = document.getElementById('sdtm-status');
  const sdtmStatusText = document.getElementById('sdtm-status-text');
  const sdtmMappingsContainer = document.getElementById('sdtm-mappings-container');
  
  // 显示SDTM分析区域
  sdtmSection.style.display = 'block';
  
  const isOk = currentSDTMData.success === true;
  if (isOk) {
    // 显示成功状态
    sdtmStatus.style.display = 'block';
    sdtmStatus.className = 'sdtm-status success';
    sdtmStatusText.textContent = 'SDTM analysis completed successfully - Please review and confirm';
    
    // 重新计算正确的去重统计数据
    updateSummaryStats();
    
    // 显示主要的编辑界面
    if (currentSDTMData.mappings && currentSDTMData.mappings.length > 0) {
      sdtmMappingsContainer.style.display = 'block';
      displayFlatMappingsList(currentSDTMData);
      setupSDTMEventListeners();
  } else {
      // 即便没有 mappings，也应显示所有 procedures 的可编辑空行
      sdtmMappingsContainer.style.display = 'block';
      displayFlatMappingsList(currentSDTMData);
      setupSDTMEventListeners();
    }
    
  } else {
    // 显示错误状态
    sdtmStatus.style.display = 'block';
    sdtmStatus.className = 'sdtm-status error';
    sdtmStatusText.textContent = sdtmAnalysis.message || 'SDTM analysis failed';
  }
}

// 更新统计数据和域概览
function updateSummaryAndDomainOverview(summary) {
  // 更新统计数据
  document.getElementById('total-procedures').textContent = summary.total_procedures || 0;
  document.getElementById('total-domains').textContent = summary.total_sdtm_domains || 0;
  
  // 更新域概览
  const domainsOverview = document.getElementById('domains-list-overview');
  domainsOverview.innerHTML = '';
  
  if (summary.unique_domains && summary.unique_domains.length > 0) {
    summary.unique_domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      domainsOverview.appendChild(domainTag);
    });
  }
  
  // 更新高复杂度SDTM
  const highComplexityOverview = document.getElementById('high-complexity-domains');
  highComplexityOverview.innerHTML = '';
  
  if (summary.highComplexitySdtm && summary.highComplexitySdtm.domains && summary.highComplexitySdtm.domains.length > 0) {
    summary.highComplexitySdtm.domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      highComplexityOverview.appendChild(domainTag);
    });
  }
  
  // 更新中复杂度SDTM
  const mediumComplexityOverview = document.getElementById('medium-complexity-domains');
  mediumComplexityOverview.innerHTML = '';
  
  if (summary.mediumComplexitySdtm && summary.mediumComplexitySdtm.domains && summary.mediumComplexitySdtm.domains.length > 0) {
    summary.mediumComplexitySdtm.domains.forEach(domain => {
      const domainTag = document.createElement('span');
      domainTag.className = 'domain-overview-tag';
      domainTag.textContent = domain;
      mediumComplexityOverview.appendChild(domainTag);
    });
  }
}

// 显示平铺式映射列表
function displayFlatMappingsList(data) {
  const flatMappingsList = document.getElementById('flat-mappings-list');
  flatMappingsList.innerHTML = '';
  
  if (!data.procedures || data.procedures.length === 0) {
    flatMappingsList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No procedures found</div>';
    return;
  }
  
  // 🔥 重要改变：遍历所有procedures，而不是只遍历mappings
  data.procedures.forEach((procedure, index) => {
    // 查找这个procedure对应的mapping
    const mapping = data.mappings ? data.mappings.find(m => m.procedure === procedure) : null;
    
    // 创建映射对象（如果没有找到mapping，创建一个空的）
    const procedureMapping = {
      procedure: procedure,
      sdtm_domains: mapping ? mapping.sdtm_domains : []
    };
    
    const mappingRow = createMappingRow(procedureMapping, index);
    flatMappingsList.appendChild(mappingRow);
  });
}

// 创建单个映射行
function createMappingRow(mapping, index) {
  const row = document.createElement('div');
  row.className = 'mapping-row';
  row.dataset.index = index;
  
  // Procedure名称
  const procedureName = document.createElement('div');
  procedureName.className = 'procedure-name';
  procedureName.textContent = mapping.procedure;
  
  // Domains区域
  const domainsArea = document.createElement('div');
  domainsArea.className = 'domains-area';
  
  // 添加现有的domain标签
  if (mapping.sdtm_domains && mapping.sdtm_domains.length > 0) {
    mapping.sdtm_domains.forEach((domain, domainIndex) => {
      const domainTag = createEditableDomainTag(domain, index, domainIndex);
      domainsArea.appendChild(domainTag);
    });
  }
  
  // 添加"添加Domain"按钮
  const addBtn = document.createElement('div');
  addBtn.className = 'add-domain-btn';
  addBtn.innerHTML = '+ Add';
  addBtn.addEventListener('click', () => addNewDomain(index));
  domainsArea.appendChild(addBtn);
  
  row.appendChild(procedureName);
  row.appendChild(domainsArea);
  
  return row;
}

// 创建可编辑的Domain标签
function createEditableDomainTag(domainText, mappingIndex, domainIndex) {
  const tag = document.createElement('span');
  tag.className = 'editable-domain-tag';
  tag.textContent = domainText;
  tag.dataset.mappingIndex = mappingIndex;
  tag.dataset.domainIndex = domainIndex;
  
  // 删除按钮
  const removeBtn = document.createElement('span');
  removeBtn.className = 'remove-domain-btn';
  removeBtn.innerHTML = '×';
  removeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    removeDomain(mappingIndex, domainIndex);
  });
  tag.appendChild(removeBtn);
  
  // 点击编辑功能
  tag.addEventListener('click', () => {
    if (isEditMode) {
      makeTagEditable(tag);
    }
  });
  
  return tag;
}

// 使标签进入可编辑状态
function makeTagEditable(tag) {
  if (tag.contentEditable === 'true') return; // 已经在编辑状态
  
  const originalText = tag.textContent.replace('×', '').trim();
  tag.innerHTML = originalText; // 移除删除按钮
  tag.contentEditable = 'true';
  tag.classList.add('editing');
  tag.focus();
  
  // 选中所有文本
  const range = document.createRange();
  range.selectNodeContents(tag);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  
  // 处理编辑完成
  const finishEditing = () => {
    tag.contentEditable = 'false';
    tag.classList.remove('editing');
    
    const newText = tag.textContent.trim();
    const mappingIndex = parseInt(tag.dataset.mappingIndex);
    const domainIndex = parseInt(tag.dataset.domainIndex);
    
    // 更新数据
    if (newText && currentSDTMData.mappings[mappingIndex]) {
      currentSDTMData.mappings[mappingIndex].sdtm_domains[domainIndex] = newText;
    }
    
    // 重新创建标签（包含删除按钮）
    const newTag = createEditableDomainTag(newText, mappingIndex, domainIndex);
    tag.parentNode.replaceChild(newTag, tag);
    
    updateSummaryStats();
  };
  
  // 监听事件
  tag.addEventListener('blur', finishEditing);
  tag.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finishEditing();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      tag.textContent = originalText;
      finishEditing();
    }
  });
}

// 删除Domain
function removeDomain(procedureIndex, domainIndex) {
  const procedureName = currentSDTMData.procedures[procedureIndex];
  if (!procedureName) return;
  
  // 查找或创建对应的mapping
  let mapping = currentSDTMData.mappings.find(m => m.procedure === procedureName);
  if (mapping && mapping.sdtm_domains && mapping.sdtm_domains[domainIndex] !== undefined) {
    // 从数据中删除
    mapping.sdtm_domains.splice(domainIndex, 1);
    
    // 重新渲染映射列表
    displayFlatMappingsList(currentSDTMData);
    
    // 更新编辑模式显示
    if (isEditMode) {
      toggleEditMode();
      toggleEditMode();
    }
    
    updateSummaryStats();
  }
}

// 添加新Domain
function addNewDomain(procedureIndex) {
  if (!isEditMode) return;
  
  const procedureName = currentSDTMData.procedures[procedureIndex];
  if (!procedureName) return;
  
  // 查找或创建对应的mapping
  let mapping = currentSDTMData.mappings.find(m => m.procedure === procedureName);
  if (!mapping) {
    // 如果mapping不存在，创建一个新的
    mapping = {
      procedure: procedureName,
      sdtm_domains: []
    };
    currentSDTMData.mappings.push(mapping);
  }
  
  // 添加空domain
  mapping.sdtm_domains.push('');
  const newDomainIndex = mapping.sdtm_domains.length - 1;
  
  // 重新渲染映射列表
  displayFlatMappingsList(currentSDTMData);
  
  // 重新设置编辑模式
  if (isEditMode) {
    toggleEditMode();
    toggleEditMode();
  }
  
  // 找到新添加的标签并开始编辑
  setTimeout(() => {
    const newTag = document.querySelector(`[data-mapping-index="${procedureIndex}"][data-domain-index="${newDomainIndex}"]`);
    if (newTag) {
      makeTagEditable(newTag);
    }
  }, 100);
}

// 设置SDTM相关的事件监听器
function setupSDTMEventListeners() {
  // 编辑按钮
  const editBtn = document.getElementById('edit-mappings-btn');
  if (editBtn) {
    editBtn.addEventListener('click', toggleEditMode);
  }
  
  // 确认按钮
  const confirmBtn = document.getElementById('confirm-mappings-btn');
  if (confirmBtn) {
    confirmBtn.addEventListener('click', confirmSDTMAnalysis);
  }
}

// 切换编辑模式
function toggleEditMode() {
  isEditMode = !isEditMode;
  const editBtn = document.getElementById('edit-mappings-btn');
  const flatMappingsList = document.getElementById('flat-mappings-list');
  
  if (editBtn) {
    const btnLabel = editBtn.querySelector('.ms-Button-label');
    btnLabel.textContent = isEditMode ? 'View Mode' : 'Edit';
  }
  
  // 更新容器的编辑模式样式
  if (isEditMode) {
    flatMappingsList.classList.add('edit-mode');
    // 为所有映射行添加编辑模式样式
    document.querySelectorAll('.mapping-row').forEach(row => {
      row.classList.add('edit-mode');
    });
  } else {
    flatMappingsList.classList.remove('edit-mode');
    // 移除所有映射行的编辑模式样式
    document.querySelectorAll('.mapping-row').forEach(row => {
      row.classList.remove('edit-mode');
    });
  }
}

// 更新统计数据
function updateSummaryStats() {
  // 基于域做去重，并按“High 优先级”归类，确保互斥
  const domainToComplexity = new Map(); // domain -> 'High' | 'Medium'

  if (Array.isArray(currentSDTMData.mappings)) {
    currentSDTMData.mappings.forEach(mapping => {
      const complexity = mapping && mapping.complexity === 'High' ? 'High' : 'Medium';
      const domains = Array.isArray(mapping?.sdtm_domains) ? mapping.sdtm_domains : [];
      domains.forEach(d => {
        const domain = (d || '').trim();
        if (!domain) return;
        const existing = domainToComplexity.get(domain);
        if (!existing) {
          domainToComplexity.set(domain, complexity);
        } else if (existing === 'Medium' && complexity === 'High') {
          // High 覆盖 Medium，保证互斥集合
          domainToComplexity.set(domain, 'High');
        }
      });
    });
  }

  const allDomains = Array.from(domainToComplexity.keys());
  const highDomains = allDomains.filter(d => domainToComplexity.get(d) === 'High');
  const mediumDomains = allDomains.filter(d => domainToComplexity.get(d) === 'Medium');

  // 更新summary对象 - 🔥 确保procedures数量是真实的
  currentSDTMData.summary.total_procedures = currentSDTMData.procedures ? currentSDTMData.procedures.length : 0;
  currentSDTMData.summary.unique_domains = allDomains;
  currentSDTMData.summary.total_sdtm_domains = allDomains.length;

  // 更新复杂度统计（互斥）
  currentSDTMData.summary.highComplexitySdtm = {
    count: highDomains.length,
    domains: highDomains
  };
  currentSDTMData.summary.mediumComplexitySdtm = {
    count: mediumDomains.length,
    domains: mediumDomains
  };

  // 更新显示
  updateSummaryAndDomainOverview(currentSDTMData.summary);

  console.log('统计数据已更新:', {
    total_procedures: currentSDTMData.summary.total_procedures,
    total_sdtm_domains: currentSDTMData.summary.total_sdtm_domains,
    unique_domains: currentSDTMData.summary.unique_domains,
    highComplexitySdtm: currentSDTMData.summary.highComplexitySdtm,
    mediumComplexitySdtm: currentSDTMData.summary.mediumComplexitySdtm
  });
}

// 确认SDTM分析结果
async function confirmSDTMAnalysis() {
  if (!window.currentDocumentId) {
    alert('No document ID found. Please re-upload the document.');
    return;
  }
  if (!currentSDTMData || !Array.isArray(currentSDTMData.procedures)) {
    showStatusMessage('No SDTM data to confirm.', 'error');
    return;
  }
  
  try {
    console.log('发送确认请求到服务器...');
    
    const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/confirm-sdtm`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        procedures: currentSDTMData.procedures || [],
        mappings: currentSDTMData.mappings || [],
        summary: currentSDTMData.summary || {}
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log('SDTM分析已确认并保存');
      
      // 显示确认状态
      const confirmationStatus = document.getElementById('confirmation-status');
      if (confirmationStatus) {
        confirmationStatus.style.display = 'flex';
      }
      
      // 隐藏编辑按钮，显示已确认状态
      const editBtn = document.getElementById('edit-mappings-btn');
      const confirmBtn = document.getElementById('confirm-mappings-btn');
      if (editBtn) editBtn.style.display = 'none';
      if (confirmBtn) confirmBtn.style.display = 'none';
      
      showStatusMessage('SDTM analysis confirmed and saved successfully!', 'success');

      // ⬇️ 根据返回的成本估算快照，填入Excel中的 Unit 与 Estimated cost
      const costEstimate = result?.data?.costEstimate;
      let sdtmDataForNotes = null;
      if (costEstimate && costEstimate['SDTM Datasets Production and Validation']) {
        await applySDTMUnitsAndCostsToExcel(costEstimate['SDTM Datasets Production and Validation']);
      }

      // 兜底拉取文档（用于 Notes 的域列表写入）
      try {
        const docResp = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
        if (docResp.ok) {
          const docData = await docResp.json();
          const snapshot = docData?.document?.costEstimate?.['SDTM Datasets Production and Validation'];
          if (!costEstimate && snapshot) {
            await applySDTMUnitsAndCostsToExcel(snapshot);
          }
          const sdtmData = docData?.document?.sdtmData;
          if (sdtmData) {
            const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
              (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
              (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
            ));
            sdtmDataForNotes = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          }
        }
      } catch (e) {
        console.warn('无法获取文档用于写入Notes:', e);
      }

      if (sdtmDataForNotes) {
        await applySDTMNotesToExcel(sdtmDataForNotes);
      }

    } else {
      console.error('确认失败:', result.message);
      showStatusMessage('Failed to confirm SDTM analysis: ' + result.message, 'error');
    }
    
  } catch (error) {
    console.error('确认请求失败:', error);
    showStatusMessage('Network error: Failed to confirm SDTM analysis', 'error');
  }
}

// ⬇️ 新增：将SDTM的 units 和 estimatedCosts 写入Excel相应行
async function applySDTMUnitsAndCostsToExcel(snapshot) {
  const taskToKey = {
    'SDTM Annotated CRFs (aCRF)': 'annotatedCrf',
    'SDTM Dataset Specs (High Complexity)': 'specsHigh',
    'SDTM Dataset Specs (Medium Complexity)': 'specsMedium',
    'SDTM Production and Validation: Programs and Datasets (High Complexity)': 'prodHigh',
    'SDTM Production and Validation: Programs and Datasets (Medium Complexity)': 'prodMedium',
    'SDTM Pinnacle 21 Report Creation and Review': 'pinnacle21',
    "SDTM Reviewer's Guide": 'reviewersGuide',
    'SDTM Define.xml': 'defineXml',
    'SDTM Dataset File xpt Conversion and Review': 'xptConversion'
  };

  try {
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getActiveWorksheet();
      const used = sheet.getUsedRange();
      used.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();

      const startRow = used.rowIndex || 0;
      const startCol = used.columnIndex || 0;
      const rows = used.values;
      const units = snapshot.units || {};
      const costs = snapshot.estimatedCosts || {};
      const subtotal = snapshot.subtotal ?? null;

      // 写每个子项的 Unit 并设置 Estimated Cost 公式
      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (!taskToKey.hasOwnProperty(task)) continue;
        const key = taskToKey[task];
        const unitVal = units[key] ?? '';

        const unitCell = sheet.getRangeByIndexes(startRow + r, startCol + 1, 1, 1); // B
        const estCostCell = sheet.getRangeByIndexes(startRow + r, startCol + 5, 1, 1); // F
        
        // 写入Unit值
        unitCell.values = [[unitVal === '' ? '' : Number(unitVal)]];
        unitCell.format.horizontalAlignment = 'Right';
        
        // 设置Estimated Cost公式 = Cost Per Hour(C) × Hours Per Unit(D)
        if (unitVal !== '') {
          const rowNum = startRow + r + 1; // Excel行号从1开始
          estCostCell.formulas = [[`=C${rowNum}*D${rowNum}`]];
          estCostCell.format.numberFormat = [["$#,##0.00"]];
          estCostCell.format.horizontalAlignment = 'Right';
        } else {
          estCostCell.values = [['']];
        }
      }

      // 定位SDTM主块后的Subtotal行，并设置SUM公式
      // 找到SDTM主标题行
      let sdtmStartRow = -1;
      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (task.toLowerCase() === 'sdtm datasets production and validation') {
          sdtmStartRow = r;
          break;
        }
      }
      if (sdtmStartRow >= 0) {
        // 向下寻找第一个值为 'Subtotal' 的行
        for (let r = sdtmStartRow + 1; r < rows.length; r++) {
          const firstCell = String(rows[r][0] || '').trim();
          if (firstCell.toLowerCase() === 'subtotal') {
            const subtotalCell = sheet.getRangeByIndexes(startRow + r, startCol + 5, 1, 1); // F
            
            // 设置SUM公式来自动计算SDTM部分的小计
            const subtotalRowNum = startRow + r + 1; // Excel行号（1-based）
            const sdtmSectionStartRow = startRow + sdtmStartRow + 2; // Excel行号：标题下一行
            const sdtmSectionEndRow = subtotalRowNum - 1; // Excel行号：Subtotal前一行
            
            // 从标题下一行到Subtotal前一行（避免包含Subtotal本身）
            subtotalCell.formulas = [[`=SUM(F${sdtmSectionStartRow}:F${sdtmSectionEndRow})`]];
            subtotalCell.format.numberFormat = [["$#,##0.00"]];
            subtotalCell.format.horizontalAlignment = 'Right';
            subtotalCell.format.font.bold = true;
            break;
          }
        }
      }

      await context.sync();
      showStatusMessage('Units, estimated costs and subtotal applied from confirmed SDTM data.', 'success');
    });
  } catch (err) {
    console.error('Failed to write SDTM units and costs:', err);
    showStatusMessage('Failed to write units/costs/subtotal to Excel: ' + err.message, 'error');
  }
}

// ⬇️ 写入 SDTM Notes（来自数据库的域列表）
async function applySDTMNotesToExcel(sdtmInfo) {
  try {
    const highDomains = sdtmInfo?.summary?.highComplexitySdtm?.domains || [];
    const mediumDomains = sdtmInfo?.summary?.mediumComplexitySdtm?.domains || [];
    const allDomains = sdtmInfo?.summary?.unique_domains || [];

    const notesMap = {
      'SDTM Dataset Specs (High Complexity)': highDomains.join('/'),
      'SDTM Dataset Specs (Medium Complexity)': mediumDomains.join('/'),
      'SDTM Dataset File xpt Conversion and Review': allDomains.join('/'),
    };

    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getActiveWorksheet();
      const used = sheet.getUsedRange();
      used.load(['values', 'rowIndex', 'columnIndex']);
      await context.sync();

      const startRow = used.rowIndex || 0;
      const startCol = used.columnIndex || 0;
      const rows = used.values;

      for (let r = 0; r < rows.length; r++) {
        const task = String(rows[r][0] || '').trim();
        if (!(task in notesMap)) continue;
        const note = notesMap[task] || '';
        const noteCell = sheet.getRangeByIndexes(startRow + r, startCol + 6, 1, 1); // 列G Notes
        noteCell.values = [[note]];
        noteCell.format.horizontalAlignment = 'Left';
      }

      await context.sync();
      showStatusMessage('Notes updated from SDTM confirmed data.', 'success');
    });
  } catch (err) {
    console.error('Failed to write SDTM notes:', err);
    showStatusMessage('Failed to write SDTM notes: ' + err.message, 'error');
  }
}

// 隐藏SDTM分析区域（在移除文件时调用）
function hideSDTMAnalysis() {
  const sdtmSection = document.getElementById('sdtm-analysis-section');
  const sdtmMappingsContainer = document.getElementById('sdtm-mappings-container');
  
  if (sdtmSection) {
    sdtmSection.style.display = 'none';
  }
  
  if (sdtmMappingsContainer) {
    sdtmMappingsContainer.style.display = 'none';
  }
  
  // 重置状态
  currentSDTMData = null;
  window.currentDocumentId = null;
  isEditMode = false;
  selectedProcedureIndex = 0;
}

// 保存Excel到本地
async function saveExcelToLocal() {
  try {
    await Excel.run(async (context) => {
      const workbook = context.workbook;
      
      // 生成文件名
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const fileName = `LLX_Cost_Analysis_${timestamp}.xlsx`;
      
      // 保存工作簿
      workbook.save();
      await context.sync();
      
      console.log('✅ Excel文件已保存:', fileName);
      showStatusMessage('Excel file saved successfully!', 'success');
    });
  } catch (error) {
    console.error('❌ 保存Excel失败:', error);
    showStatusMessage('Failed to save Excel: ' + error.message, 'error');
  }
}

// 清空Excel内容
async function clearExcelContent() {
  try {
    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // 获取已使用范围
      const usedRange = worksheet.getUsedRange();
      if (usedRange) {
        usedRange.clear();
        await context.sync();
      }
      
      console.log('✅ Excel内容已清空');
      showStatusMessage('Excel content cleared for new project!', 'success');
    });
  } catch (error) {
    console.error('❌ 清空Excel失败:', error);
    showStatusMessage('Failed to clear Excel: ' + error.message, 'error');
  }
}

// 重置到开始状态
async function resetToStart() {
  try {
    // 清除状态变量
    uploadedProtocol = null;
    window.currentDocumentId = null;
    currentSDTMData = null;
    isEditMode = false;
    selectedProcedureIndex = 0;
    
    // 清除Excel设置
    await clearDocumentIdFromSettings();
    
    // 重置项目选择状态
    const checkboxes = document.querySelectorAll('.project-options input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      checkbox.checked = false;
      const dataAttr = checkbox.getAttribute('data-requires-count');
      if (dataAttr) {
        const container = document.getElementById(`${dataAttr}-container`);
        const input = document.getElementById(`${dataAttr}-count`);
        if (container) container.style.display = 'none';
        if (input) input.value = '';
      }
    });
    
    // 重置上传界面
    document.getElementById('protocol-upload-area').style.display = 'block';
    document.getElementById('protocol-progress').style.display = 'none';
    document.getElementById('protocol-result').style.display = 'none';
    document.getElementById('protocol-file-input').value = '';
    
    // 隐藏SDTM分析
    hideSDTMAnalysis();
    
    // 🔥 重置AI助手聊天记录
    resetAIChatInterface();
    
    // 回到第1步
    showStep(1);
    
    console.log('✅ 应用状态已重置');
    showStatusMessage('Ready for new project!', 'success');
    
  } catch (error) {
    console.error('❌ 重置状态失败:', error);
    showStatusMessage('Failed to reset: ' + error.message, 'error');
  }
}

// 🔥 新增：自动创建标准成本分析表格标题
async function createStandardCostAnalysisHeaders() {
  try {
    await Excel.run(async (context) => {
      // 获取当前活动的工作表
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      
      // 定义标准的列标题
      const headers = [
        "Task",
        "Unit", 
        "Cost Per Hour",
        "# of Hours Per Unit",
        "Cost Per Unit",
        "Estimated cost",
        "Notes"
      ];
      
      // 获取第一行的范围（A1:G1）
      const headerRange = worksheet.getRange("A1:G1");
      
      // 设置标题值
      headerRange.values = [headers];
      
      // 设置格式：粗体
      headerRange.format.font.bold = true;
      
      // 可选：设置其他格式
      headerRange.format.font.size = 12;
      headerRange.format.fill.color = "#E7E7E7"; // 浅灰色背景
      headerRange.format.borders.getItem("EdgeTop").style = "Continuous";
      headerRange.format.borders.getItem("EdgeBottom").style = "Continuous";
      headerRange.format.borders.getItem("EdgeLeft").style = "Continuous";
      headerRange.format.borders.getItem("EdgeRight").style = "Continuous";
      headerRange.format.borders.getItem("InsideVertical").style = "Continuous";
      
      // 自动调整列宽
      headerRange.format.autofitColumns();

      await context.sync();
      
      console.log('✅ 标准成本分析表格标题已创建');
      showStatusMessage('Excel table headers created successfully!', 'success');
    });
  } catch (error) {
    console.error('❌ 创建Excel标题时出错:', error);
    showStatusMessage('Failed to create Excel headers: ' + error.message, 'error');
  }
}

// 🔥 新增：根据项目选择填写Excel任务列表（上传时仅生成框架，不写Unit/Estimated cost）
async function populateExcelWithSelectedProjects() {
  try {
    // 从MongoDB获取已保存的项目选择详情和SDTM数据
    let savedProjectDetails = {};
    let sdtmInfo = null;
    if (window.currentDocumentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/content`);
        if (response.ok) {
          const docData = await response.json();
          if (docData.document && docData.document.projectSelectionDetails) {
            savedProjectDetails = docData.document.projectSelectionDetails;
          }
          // 获取SDTM数据（此处仅用于展示，不用于写Unit）
          if (docData.document && docData.document.sdtmData) {
            const sdtmData = docData.document.sdtmData;
            const hasValidConfirmed = !!(sdtmData.confirmed && sdtmData.confirmed.summary && (
              (typeof sdtmData.confirmed.summary.total_sdtm_domains === 'number' && sdtmData.confirmed.summary.total_sdtm_domains > 0) ||
              (Array.isArray(sdtmData.confirmed.summary.unique_domains) && sdtmData.confirmed.summary.unique_domains.length > 0)
            ));
            sdtmInfo = hasValidConfirmed ? sdtmData.confirmed : sdtmData.original;
          }
        }
      } catch (error) {
        console.warn('无法获取已保存的项目详情，使用当前选择:', error);
      }
    }
    
    if (Object.keys(savedProjectDetails).length === 0) {
      const { projectSelectionDetails } = collectProjectSelectionDetails();
      savedProjectDetails = projectSelectionDetails;
    }

    const highComplexityCount = sdtmInfo?.summary?.highComplexitySdtm?.count || 0;
    const mediumComplexityCount = sdtmInfo?.summary?.mediumComplexitySdtm?.count || 0;
    const totalDomainsCount = sdtmInfo?.summary?.total_sdtm_domains || 0;

    await Excel.run(async (context) => {
      const worksheet = context.workbook.worksheets.getActiveWorksheet();
      let currentRow = 2;

      if (Object.keys(savedProjectDetails).length > 0) {
        for (const [projectName, count] of Object.entries(savedProjectDetails)) {
          if (projectName === 'lastUpdated') continue;

          const isSDTM = projectName.toLowerCase().includes("sdtm");
          const isADAM = projectName.toLowerCase().includes("adam");
          const isDSUR = projectName.toLowerCase().includes("dsur");
          const isDSMB = projectName.toLowerCase().includes("dsmb");
          const isStatisticalAnalysisPlan = projectName.toLowerCase().includes("statistical analysis plan");

          if (isSDTM || isADAM || isStatisticalAnalysisPlan) {
            const projectNameRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            projectNameRange.values = [[projectName, "", "", "", "", "", ""]];
            projectNameRange.format.font.bold = true;
            projectNameRange.format.horizontalAlignment = "Left";
            currentRow++;
            const sectionTitleRow = currentRow - 1; // 记录分节标题所在行（用于计算Subtotal范围）

            if (isSDTM) {
              const sdtmSubItems = [
                { name: "SDTM Annotated CRFs (aCRF)", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Dataset Specs (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 3, costPerUnit: 3.0 },
                { name: "SDTM Dataset Specs (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 2, costPerUnit: 2.0 },
                { name: "SDTM Production and Validation: Programs and Datasets (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 16, costPerUnit: 16.0 },
                { name: "SDTM Production and Validation: Programs and Datasets (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 10, costPerUnit: 10.0 },
                { name: "SDTM Pinnacle 21 Report Creation and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 6, costPerUnit: 6.0 },
                { name: "SDTM Reviewer's Guide", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Define.xml", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "SDTM Dataset File xpt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 }
              ];

              for (const subItem of sdtmSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[
                  subItem.name,
                  "", // Unit 留空，待确认后填入
                  `$${subItem.costPerHour}`,
                  subItem.hoursPerUnit,
                  `$${subItem.costPerUnit}`,
                  "", // Estimated Cost 留空，将用公式计算
                  ""
                ]];
                
                // 为Estimated Cost列(F)设置Excel公式：=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            } else if (isADAM) {
              // ADAM 保持原有占位（Unit 留空）
              const adamSubItems = [
                { name: "ADaM Dataset Specs (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 3, costPerUnit: 3.0 },
                { name: "ADaM Dataset Specs (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 2, costPerUnit: 2.0 },
                { name: "ADaM Production and Validation: Programs and Datasets (High Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 18, costPerUnit: 18.0 },
                { name: "ADaM Production and Validation: Programs and Datasets (Medium Complexity)", unit: "", costPerHour: 1.0, hoursPerUnit: 10, costPerUnit: 10.0 },
                { name: "ADaM Pinnacle 21 Report Creation and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 4, costPerUnit: 4.0 },
                { name: "ADaM Reviewer's Guide", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "ADaM Define.xml", unit: "", costPerHour: 1.0, hoursPerUnit: 32, costPerUnit: 32.0 },
                { name: "ADaM Dataset Program xpt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 },
                { name: "ADaM Program txt Conversion and Review", unit: "", costPerHour: 1.0, hoursPerUnit: 0.2, costPerUnit: 0.2 }
              ];

              for (const subItem of adamSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[
                  subItem.name,
                  "",
                  `$${subItem.costPerHour}`,
                  subItem.hoursPerUnit,
                  `$${subItem.costPerUnit}`,
                  "",
                  ""
                ]];
                
                // 为Estimated Cost列(F)设置Excel公式：=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            } else if (isStatisticalAnalysisPlan) {
              const sapSubItems = [
                { name: "Statistical Analysis Plan Draft 1", unit: "", costPerHour: 1.0, hoursPerUnit: 40, costPerUnit: 40.0 },
                { name: "Statistical Analysis Plan Draft 2", unit: "", costPerHour: 1.0, hoursPerUnit: 30, costPerUnit: 30.0 },
                { name: "Statistical Analysis Plan Final", unit: "", costPerHour: 1.0, hoursPerUnit: 20, costPerUnit: 20.0 },
                { name: "Analysis Shells Development", unit: "", costPerHour: 1.0, hoursPerUnit: 60, costPerUnit: 60.0 },
                { name: "Mock Tables, Listings, and Figures", unit: "", costPerHour: 1.0, hoursPerUnit: 40, costPerUnit: 40.0 }
              ];
              for (const subItem of sapSubItems) {
                const subItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                subItemRange.values = [[subItem.name, "", `$${subItem.costPerHour}`, subItem.hoursPerUnit, `$${subItem.costPerUnit}`, "", ""]];
                
                // 为Estimated Cost列(F)设置Excel公式：=C*D
                const estimatedCostCell = worksheet.getRange(`F${currentRow}`);
                estimatedCostCell.formulas = [[`=C${currentRow}*D${currentRow}`]];
                estimatedCostCell.format.numberFormat = [["$#,##0.00"]];
                
                subItemRange.format.font.bold = false;
                subItemRange.format.horizontalAlignment = "Left";
                const numberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                numberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
            }

            // Subtotal for main section with Excel SUM formula
            const mainSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            mainSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
            
            // 计算当前部分的开始行（项目标题行+1）和结束行（当前行-1）
            // 修正：sectionStartRow = 项目标题行的下一行；
            // 由于我们每次进入该分节时先写了标题并 currentRow++，随后写了N个子项，再到此处写Subtotal，
            // 此时 currentRow 指向Subtotal行，因此：
            //   sectionEndRow = currentRow - 1（最后一个子项）
            //   sectionStartRow = sectionEndRow - (子项数量 - 1)
            // 这里不再用硬编码数量，改为从标题行缓存：
            const subtotalRow = currentRow;
            const lastItemRow = subtotalRow - 1;
            const firstItemRow = (isSDTM || isADAM || isStatisticalAnalysisPlan) ? (sectionTitleRow + 1) : (sectionTitleRow + 1);
            
            // 为Subtotal的F列设置SUM公式
            const subtotalCell = worksheet.getRange(`F${currentRow}`);
            subtotalCell.formulas = [[`=SUM(F${firstItemRow}:F${lastItemRow})`]];
            subtotalCell.format.numberFormat = [["$#,##0.00"]];
            subtotalCell.format.font.bold = true;
            
            mainSubtotalRange.format.font.bold = true;
            mainSubtotalRange.format.horizontalAlignment = "Right";
            currentRow++;

            // Transfer blocks remain unchanged
            if (count && count > 0 && (isSDTM || isADAM)) {
              const transferSubsection = isSDTM ? `SDTM Dataset Transfer (${count} times)` : `ADAM Dataset Transfer (${count} times)`;
              const transferRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              transferRange.values = [[transferSubsection, "", "", "", "", "", ""]];
              transferRange.format.font.bold = true;
              transferRange.format.horizontalAlignment = "Left";
              currentRow++;

              const transferSubItems = isSDTM ? [
                { name: `Production and Validation, the first 2 times`, unit: 2, costPerHour: 1.0, hoursPerUnit: 25, costPerUnit: 25.0 },
                { name: `Production and Validation, the last ${count - 2} times`, unit: count - 2, costPerHour: 1.0, hoursPerUnit: 12.5, costPerUnit: 12.5 }
              ] : [
                { name: `Production and Validation, the first 2 times`, unit: 2, costPerHour: 1.0, hoursPerUnit: 15, costPerUnit: 15.0 },
                { name: `Production and Validation, the last ${count - 2} times`, unit: count - 2, costPerHour: 1.0, hoursPerUnit: 7.5, costPerUnit: 7.5 }
              ];
              for (const transferSubItem of transferSubItems) {
                const transferSubItemRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
                transferSubItemRange.values = [[transferSubItem.name, "", `$${transferSubItem.costPerHour}`, transferSubItem.hoursPerUnit, `$${transferSubItem.costPerUnit}`, "", ""]];
                transferSubItemRange.format.font.bold = false;
                transferSubItemRange.format.horizontalAlignment = "Left";
                const transferNumberColumns = worksheet.getRange(`B${currentRow}:F${currentRow}`);
                transferNumberColumns.format.horizontalAlignment = "Right";
                currentRow++;
              }
              const transferSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              transferSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
              transferSubtotalRange.format.font.bold = true;
              transferSubtotalRange.format.horizontalAlignment = "Right";
              currentRow++;
            }

          } else if (isDSUR || isDSMB) {
            if (count && count > 0) {
              const rerunSubsection = isDSUR ? `DSUR Rerun (${count} times)` : `DSMB Rerun (${count} times)`;
              const rerunRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              rerunRange.values = [[rerunSubsection, "", "", "", "", "", ""]];
              rerunRange.format.font.bold = true;
              rerunRange.format.horizontalAlignment = "Left";
              currentRow++;
              const rerunSubtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
              rerunSubtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
              rerunSubtotalRange.format.font.bold = true;
              rerunSubtotalRange.format.horizontalAlignment = "Right";
              currentRow++;
            }
          } else {
            const projectNameRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            projectNameRange.values = [[projectName, "", "", "", "", "", ""]];
            projectNameRange.format.font.bold = true;
            projectNameRange.format.horizontalAlignment = "Left";
            currentRow++;
            const subtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
            subtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
            subtotalRange.format.font.bold = true;
            subtotalRange.format.horizontalAlignment = "Right";
            currentRow++;
          }
        }
      }

      // 默认末尾三部分
      const defaultSections = [
        'License Fees',
        'Adhoc Analysis',
        'Project Management/Administration(12 Months)'
      ];
      for (const sectionName of defaultSections) {
        const range = worksheet.getRange(`A${currentRow}:G${currentRow}`);
        range.values = [[sectionName, "", "", "", "", "", ""]];
        range.format.font.bold = true;
        range.format.horizontalAlignment = 'Left';
        currentRow++;
        const subtotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
        subtotalRange.values = [["Subtotal", "", "", "", "", "", ""]];
        subtotalRange.format.font.bold = true;
        subtotalRange.format.horizontalAlignment = 'Right';
        currentRow++;
      }

      // Grand Total
      const grandTotalRange = worksheet.getRange(`A${currentRow}:G${currentRow}`);
      grandTotalRange.values = [["Grand Total", "", "", "", "", "", ""]];
      grandTotalRange.format.font.bold = true;
      grandTotalRange.format.horizontalAlignment = 'Right';
    });
  } catch (error) {
    console.error('填充Excel任务列表失败:', error);
    showStatusMessage('Failed to populate Excel: ' + error.message, 'error');
  }
}

// 🔥 新增：项目选择动态输入框逻辑
function initProjectSelectionLogic() {
  // 获取所有需要动态输入框的checkbox
  const checkboxesWithCounts = document.querySelectorAll('[data-requires-count]');
  
  checkboxesWithCounts.forEach(checkbox => {
    checkbox.addEventListener('change', function() {
      const countType = this.getAttribute('data-requires-count');
      const container = document.getElementById(`${countType}-container`);
      
      if (container) {
        if (this.checked) {
          // 显示输入框
          container.style.display = 'flex';
          // 聚焦到输入框
          const input = container.querySelector('.count-input');
          if (input) {
            setTimeout(() => input.focus(), 300);
          }
        } else {
          // 隐藏输入框并清空值
          container.style.display = 'none';
          const input = container.querySelector('.count-input');
          if (input) {
            input.value = '';
          }
        }
      }
    });
  });
}

// 🔥 新增：收集项目选择详细信息 (简化格式: 项目名->次数)
function collectProjectSelectionDetails() {
  const projectSelectionDetails = {};
  
  // 收集所有勾选的项目和对应的次数
  const allCheckboxes = document.querySelectorAll('.ms-CheckBox-input');
  allCheckboxes.forEach((checkbox) => {
    if (checkbox.checked) {
      const projectName = checkbox.parentElement.querySelector('.ms-CheckBox-text').textContent.trim();
      
      // 根据项目类型获取对应的数量输入框
      let count = null;
      const requiresCount = checkbox.getAttribute('data-requires-count');
      
      if (requiresCount) {
        const countInput = document.getElementById(`${requiresCount}-count`);
        if (countInput && countInput.value) {
          count = parseInt(countInput.value);
        }
      }
      
      // 直接存储: "项目名": 次数 (没有次数则为null)
      projectSelectionDetails[projectName] = count;
    }
  });
  
  return {
    projectSelectionDetails
  };
}

// 🔥 新增：保存项目选择详细信息到后端
async function saveProjectSelectionDetails() {
  try {
    if (!window.currentDocumentId) {
      console.warn('没有当前文档ID，跳过保存项目选择详情');
      return;
    }
    
    const { projectSelectionDetails } = collectProjectSelectionDetails();
    
    // 检查是否有任何项目选择
    if (Object.keys(projectSelectionDetails).length === 0) {
      console.log('没有项目选择，跳过保存');
      return;
    }
    
    const response = await fetch(`${API_BASE_URL}/api/documents/${window.currentDocumentId}/project-selection`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ projectSelectionDetails })
    });
    
    if (response.ok) {
      console.log('✅ 项目选择详情已自动保存');
      showStatusMessage('Project selection automatically saved with document!', 'success');
    } else {
      throw new Error('保存项目选择详情失败');
    }
    
  } catch (error) {
    console.error('❌ 保存项目选择详情时出错:', error);
    // 不显示错误消息，因为这是自动保存，不应该干扰用户体验
  }
}




